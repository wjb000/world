<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crypto World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            background: #000;
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            color: white;
            margin-top: 20px;
            font-size: 18px;
            letter-spacing: 2px;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(30, 30, 30, 0.8));
            padding: 15px 30px;
            border-radius: 15px;
            font-size: 14px;
            text-align: center;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #siteTitle {
            position: absolute;
            top: 20px;
            left: 20px;
            text-align: left;
            pointer-events: none;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 204, 255, 0.15), rgba(0, 153, 204, 0.15));
            padding: 15px 25px;
            border-radius: 15px;
            border: 3px solid #00ccff;
            box-shadow: 0 0 30px rgba(0, 204, 255, 0.6), 0 0 60px rgba(0, 204, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        #siteTitle h1 {
            margin: 0;
            font-size: 36px;
            font-weight: bold;
            color: #00ccff;
            text-shadow:
                0 0 10px rgba(0, 204, 255, 0.8),
                0 0 20px rgba(0, 204, 255, 0.6),
                0 0 30px rgba(0, 204, 255, 0.4);
            animation: titleGlow 2s ease-in-out infinite;
        }

        #siteTitle p {
            margin: 5px 0 0 0;
            font-size: 14px;
            color: #00ccff;
            text-shadow:
                0 0 5px rgba(0, 204, 255, 0.5),
                0 0 10px rgba(0, 204, 255, 0.3);
        }

        @keyframes titleGlow {

            0%,
            100% {
                text-shadow:
                    0 0 10px rgba(0, 204, 255, 0.8),
                    0 0 20px rgba(0, 204, 255, 0.6),
                    0 0 30px rgba(0, 204, 255, 0.4);
            }

            50% {
                text-shadow:
                    0 0 20px rgba(0, 204, 255, 1),
                    0 0 30px rgba(0, 204, 255, 0.8),
                    0 0 40px rgba(0, 204, 255, 0.6);
            }
        }

        #joystick {
            position: absolute;
            bottom: 80px;
            left: 80px;
            width: 140px;
            height: 140px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            border: 3px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: none;
            touch-action: none;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #joystick-knob {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.5));
            border: 3px solid white;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
        }

        .desktop-only {
            display: inline;
        }

        .mobile-only {
            display: none;
        }

        @media (max-width: 768px) {
            #joystick {
                display: block;
            }

            #instructions {
                font-size: 12px;
                padding: 10px 15px;
                top: 10px;
            }

            .desktop-only {
                display: none;
            }

            .mobile-only {
                display: inline;
            }

            #loading {
                padding: 10px;
            }

            .loading-text {
                font-size: 14px;
            }

            #siteTitle {
                padding: 6px 8px;
                top: 10px;
                left: 2px;
                border-width: 2px;
                max-width: 120px;
            }

            #siteTitle h1 {
                font-size: 16px;
            }

            #siteTitle p {
                font-size: 8px;
            }
        }

        @media (max-width: 480px) {
            #joystick {
                bottom: 60px;
                left: 60px;
                width: 120px;
                height: 120px;
            }

            #instructions {
                font-size: 11px;
                padding: 8px 12px;
            }

            #siteTitle {
                padding: 5px 6px;
                top: 8px;
                left: 2px;
                max-width: 110px;
            }

            #siteTitle h1 {
                font-size: 14px;
            }

            #siteTitle p {
                font-size: 7px;
            }
        }

        /* Loot item popup - shared styles */
        .lootPopup {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            padding: 20px 30px;
            border-radius: 15px;
            border: 4px solid;
            z-index: 1000;
            display: none;
            text-align: center;
            min-width: 300px;
            pointer-events: none;
        }

        .lootPopup.visible {
            display: block;
            animation: popupBounce 0.5s ease;
        }

        .lootPopup button {
            pointer-events: all;
        }

        /* Gold/legendary popup for iPhone */
        #lootPopup {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 170, 0, 0.95));
            border-color: #ffd700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.4);
        }

        /* Purple/epic popup for Apple Watch */
        #lootPopup2 {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.95), rgba(75, 0, 130, 0.95));
            border-color: #9370db;
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.8), 0 0 60px rgba(138, 43, 226, 0.4);
        }

        /* Green/emerald popup for Resume */
        #lootPopup3 {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.95), rgba(5, 150, 105, 0.95));
            border-color: #10b981;
            box-shadow: 0 0 30px rgba(16, 185, 129, 0.8), 0 0 60px rgba(16, 185, 129, 0.4);
        }

        /* Orange popup for GitHub */
        #lootPopup4 {
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.95), rgba(234, 88, 12, 0.95));
            border-color: #f97316;
            box-shadow: 0 0 30px rgba(249, 115, 22, 0.8), 0 0 60px rgba(249, 115, 22, 0.4);
        }

        /* Blue/cyan popup for BOB Robot Project */
        #lootPopupBobProject {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.95), rgba(8, 145, 178, 0.95));
            border-color: #06b6d4;
            box-shadow: 0 0 30px rgba(6, 182, 212, 0.8), 0 0 60px rgba(6, 182, 212, 0.4);
        }

        /* Coral/orange popup for AGV Project */
        #agvPopup {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.95), rgba(255, 69, 0, 0.95));
            border-color: #ff6b35;
            box-shadow: 0 0 30px rgba(255, 107, 53, 0.8), 0 0 60px rgba(255, 107, 53, 0.4);
        }

        /* Pink/magenta popup for Cover Letter */
        #coverLetterPopup {
            background: linear-gradient(135deg, rgba(233, 30, 99, 0.95), rgba(194, 24, 91, 0.95));
            border-color: #e91e63;
            box-shadow: 0 0 30px rgba(233, 30, 99, 0.8), 0 0 60px rgba(233, 30, 99, 0.4);
        }

        @keyframes popupBounce {
            0% {
                transform: translateX(-50%) scale(0.8);
                opacity: 0;
            }

            50% {
                transform: translateX(-50%) scale(1.05);
            }

            100% {
                transform: translateX(-50%) scale(1);
                opacity: 1;
            }
        }

        .lootPopup h3 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 20px;
            text-transform: uppercase;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .lootPopup p {
            margin: 0 0 15px 0;
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .lootPopup button {
            background: linear-gradient(135deg, #fff, #ffe);
            color: #000;
            border: 3px solid;
            padding: 12px 40px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }

        #lootPopup button {
            border-color: #ffd700;
        }

        #lootPopup2 button {
            border-color: #9370db;
        }

        #lootPopup3 button {
            border-color: #10b981;
        }

        #lootPopup4 button {
            border-color: #f97316;
        }

        #lootPopupBobProject button {
            border-color: #06b6d4;
        }

        .lootPopup button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #ffffaa, #ffff88);
        }

        .lootPopup button:active {
            transform: scale(0.95);
        }

        /* Password screen */
        #passwordScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        #passwordScreen.hidden {
            display: none;
        }

        .password-container {
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            text-align: center;
            max-width: 400px;
        }

        .password-container h2 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 28px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .password-container p {
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 25px;
            font-size: 14px;
        }

        #passwordInput {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            text-align: center;
            margin-bottom: 15px;
            box-sizing: border-box;
        }

        #passwordInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        #passwordInput:focus {
            outline: none;
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        #submitPassword {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(135deg, #00ffff, #00aaff);
            color: #000;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        #submitPassword:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.5);
        }

        #submitPassword:active {
            transform: scale(0.95);
        }

        .password-error {
            color: #ff6b6b;
            margin-top: 10px;
            font-size: 14px;
            display: none;
        }

        .password-error.show {
            display: block;
        }

        /* Multiplayer Color Picker - Hidden until 2+ players */
        #colorPickerIcon {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.3s;
            z-index: 10000;
            opacity: 0;
        }

        #colorPickerIcon.visible {
            display: flex;
            opacity: 1;
        }

        #colorPickerIcon:hover {
            transform: scale(1.1);
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        #colorPickerPopup {
            position: fixed;
            bottom: 130px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: none;
            z-index: 10001;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
        }

        #colorPickerPopup.visible {
            display: block;
        }

        #playerCount {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 8px;
            color: #fff;
            font-size: 16px;
            z-index: 10000;
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #playerCount.visible {
            display: block;
            opacity: 1;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <style>
        /* Wallet Screen Styles */
        #walletScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.3s;
        }

        #walletScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .wallet-container {
            text-align: center;
            color: white;
            max-width: 500px;
            padding: 40px;
        }

        .wallet-container h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #00ff41;
        }

        .wallet-container p {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 40px;
        }

        .wallet-options {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .wallet-btn {
            background: rgba(255,255,255,0.05);
            border: 2px solid #00ff41;
            padding: 30px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            font-size: 20px;
            min-width: 180px;
        }

        .wallet-btn:hover {
            background: rgba(0,255,65,0.1);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,255,65,0.3);
        }

        .wallet-btn div:first-child {
            font-size: 48px;
            margin-bottom: 10px;
        }
    </style>
</head>

<body>
    <!-- Player Count Display -->
    <div id="playerCount">Players: 1</div>

    <!-- Color Picker -->
    <!-- Minimal Color Picker -->
    <div id="colorPickerIcon">üé®</div>
    <div id="colorPickerPopup">
        <input type="color" id="colorInput" value="#00ccff" style="width: 150px; height: 150px; border: none; cursor: pointer; background: transparent;">
    </div>

    <script>
        // Color picker collapse/expand toggle
        // Minimal color picker controls
        const colorPickerIcon = document.getElementById('colorPickerIcon');
        const colorPickerPopup = document.getElementById('colorPickerPopup');
        const colorInput = document.getElementById('colorInput');
        let colorPickerOpen = false;

        colorPickerIcon.addEventListener('click', () => {
            colorPickerOpen = !colorPickerOpen;
            if (colorPickerOpen) {
                colorPickerPopup.classList.add('visible');
            } else {
                colorPickerPopup.classList.remove('visible');
            }
        });

        // Close popup when clicking outside
        document.addEventListener('click', (e) => {
            if (!colorPickerIcon.contains(e.target) && !colorPickerPopup.contains(e.target)) {
                colorPickerOpen = false;
                colorPickerPopup.classList.remove('visible');
            }
        });
    </script>

    <!-- Wallet Connection Screen -->
    <div id="walletScreen">
        <div class="wallet-container">
            <h1>üåç Crypto World</h1>
            <p>Connect your wallet to enter the metaverse</p>
            <div class="wallet-options">
                <button class="wallet-btn" id="connectPhantom">
                    <div>üëª</div>
                    <div>Phantom</div>
                    <div style="font-size: 11px; color: #aaa;">Solana</div>
                </button>
            </div>
            <p style="font-size: 12px; color: #666;">Your wallet is your identity in the metaverse</p>
        </div>
    </div>

    <!-- HUD Overlay -->
    <div id="hud" style="display: none; position: fixed; top: 20px; left: 20px; color: white; font-family: monospace; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; z-index: 100;">
        <div id="hudWallet" style="margin-bottom: 5px;">Wallet: Loading...</div>
        <div id="hudBalance" style="margin-bottom: 5px;">Balance: Loading...</div>
        <button id="disconnectBtn" style="margin-top: 10px; padding: 5px 10px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">Disconnect</button>
    </div>
    <div id="loading">
        <div class="loader"></div>
        <div class="loading-text">LOADING WORLD...</div>
    </div>

    <div id="instructions">
        <span class="desktop-only"><strong>WASD</strong> to Move | <strong>SHIFT</strong> to Sprint</span>
        <span class="mobile-only"><strong>Joystick</strong> to Move</span>
    </div>

    <!-- Site title removed -->

    <div id="joystick">
        <div id="joystick-knob"></div>
    </div>

    <!-- Proximity Chat UI - Collapsible -->
    <!-- Minecraft-style Chat Container -->
    <div id="chatContainer" style="display: none; position: fixed; bottom: 10px; left: 10px; width: 400px; max-width: 90vw; z-index: 100;">
        <!-- Messages Display (Always visible) -->
        <div id="chatMessages" style="max-height: 250px; overflow-y: auto; padding: 5px; display: flex; flex-direction: column; gap: 2px;"></div>

        <!-- Chat Input Bar (Hidden by default) -->
        <div id="chatInputBar" style="display: none; margin-top: 5px; background: rgba(0, 0, 0, 0.5); padding: 8px; border-radius: 3px;">
            <div style="display: flex; gap: 5px;">
                <input type="text" id="chatInput" placeholder="Press Enter to send..." style="flex: 1; padding: 8px; background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255, 255, 255, 0.3); color: white; outline: none; font-family: monospace; font-size: 13px;" maxlength="200">
                <button id="sendBtn" style="padding: 8px 15px; background: rgba(0, 200, 0, 0.7); color: white; border: none; cursor: pointer; font-weight: bold; font-size: 12px;">Send</button>
            </div>
            <div style="margin-top: 4px; color: rgba(255, 255, 255, 0.5); font-size: 10px; font-family: monospace;">Within 50 units ¬∑ <span id="nearbyCount">0 nearby</span></div>
        </div>

        <!-- Open Chat Button -->
        <button id="openChatBtn" style="margin-top: 5px; padding: 6px 12px; background: rgba(0, 0, 0, 0.5); color: white; border: 1px solid rgba(255, 255, 255, 0.3); cursor: pointer; font-size: 12px; font-family: monospace; border-radius: 3px;">Press T to chat</button>
    </div>

    <script>
        // Minecraft-style chat controls
        const chatInputBar = document.getElementById('chatInputBar');
        const chatInput = document.getElementById('chatInput');
        const openChatBtn = document.getElementById('openChatBtn');
        let chatOpen = false;

        // Toggle chat input
        function toggleChatInput(open) {
            chatOpen = open;
            if (open) {
                chatInputBar.style.display = 'block';
                openChatBtn.style.display = 'none';
                chatInput.focus();
            } else {
                chatInputBar.style.display = 'none';
                openChatBtn.style.display = 'block';
                chatInput.value = '';
            }
        }

        // Open chat button click
        openChatBtn.addEventListener('click', () => toggleChatInput(true));

        // T key to open chat
        document.addEventListener('keydown', (e) => {
            if (e.key === 't' || e.key === 'T') {
                if (!chatOpen && document.activeElement.tagName !== 'INPUT') {
                    e.preventDefault();
                    toggleChatInput(true);
                }
            }
            // ESC to close chat
            if (e.key === 'Escape' && chatOpen) {
                toggleChatInput(false);
            }
        });

        // Enter key to send message (handled in sendMessage function)
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('sendBtn').click();
            }
        });
    </script>

    <!-- Simplified loot popups - all say HELLO WORLD -->
    <div id="lootPopup" class="lootPopup" style="background: rgba(0,0,0,0.95);">
        <h3 style="color: white;">HELLO WORLD</h3>
        <p style="color: white;">Interactive Sign</p>
    </div>

    <div id="lootPopup2" class="lootPopup" style="background: rgba(0,0,0,0.95);">
        <h3 style="color: white;">HELLO WORLD</h3>
        <p style="color: white;">Interactive Sign</p>
    </div>

    <div id="lootPopup3" class="lootPopup" style="background: rgba(0,0,0,0.95);">
        <h3 style="color: white;">HELLO WORLD</h3>
        <p style="color: white;">Interactive Sign</p>
    </div>

    <div id="agvPopup" class="lootPopup agvPopup" style="background: rgba(0,0,0,0.95);">
        <h3 style="color: white;">HELLO WORLD</h3>
        <p style="color: white;">Interactive Sign</p>
    </div>

    <div id="lootPopup4" class="lootPopup" style="background: rgba(0,0,0,0.95);">
        <h3 style="color: white;">HELLO WORLD</h3>
        <p style="color: white;">Interactive Sign</p>
    </div>

    <div id="coverLetterPopup" class="lootPopup" style="background: rgba(0,0,0,0.95);">
        <h3 style="color: white;">HELLO WORLD</h3>
        <p style="color: white;">Interactive Sign</p>
    </div>

    <div id="lootPopupBobProject" class="lootPopup" style="background: rgba(0,0,0,0.95);">
        <h3 style="color: white;">HELLO WORLD</h3>
        <p style="color: white;">Interactive Sign</p>
    </div>

    <!-- BOB Robot Project Modal -->
    <div id="bobProjectModal" class="lootPopup"
        style="width: 90vw; max-width: 1400px; height: 90vh; overflow-y: auto; padding: 40px; background: linear-gradient(135deg, #0a0e14, #1a2332); z-index: 10000;">
        <button id="closeBobProject"
            style="position: absolute; top: 20px; right: 20px; font-size: 32px; background: rgba(239,68,68,0.8); border: none; color: white; padding: 15px 25px; cursor: pointer; border-radius: 10px; z-index: 10001;">‚úï</button>

        <h2
            style="font-size: 48px; text-align: center; margin-bottom: 30px; color: #fff; text-shadow: 0 0 20px rgba(6,182,212,0.8);">
            ü§ñ ROBOT PROJECT</h2>

        <!-- Video Demo -->
        <div
            style="position: relative; margin-bottom: 40px; border-radius: 16px; overflow: hidden; background: linear-gradient(135deg, rgba(6,182,212,0.1), rgba(8,145,178,0.1)); padding: 4px; box-shadow: 0 0 40px rgba(6,182,212,0.6), inset 0 0 20px rgba(6,182,212,0.1);">
            <div style="background: #000; border-radius: 12px; overflow: hidden;">
                <div style="padding:75% 0 0 0;position:relative;">
                    <div style="position:absolute;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg, rgba(6,182,212,0.2), rgba(8,145,178,0.2));">
                        <div style="text-align:center;color:#06b6d4;">
                            <div style="font-size:48px;margin-bottom:20px;">ü§ñ</div>
                            <div style="font-size:24px;font-weight:bold;">BOB Robot Project</div>
                            <div style="font-size:16px;margin-top:10px;opacity:0.8;">Interactive Demo Coming Soon</div>
                        </div>
                    </div>
                    <!-- Vimeo video disabled due to privacy settings
                    <iframe
                        src="https://player.vimeo.com/video/1160996063?autoplay=1&loop=1&autopause=0&muted=1&background=1&quality=1080p"
                        frameborder="0"
                        allow="autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share"
                        referrerpolicy="strict-origin-when-cross-origin"
                        style="position:absolute;top:0;left:0;width:100%;height:100%;" title="Robot Demo"></iframe>
                    -->
                </div>
            </div>
            <div
                style="position: absolute; bottom: 12px; right: 12px; background: rgba(6,182,212,0.9); padding: 8px 16px; border-radius: 8px; font-family: 'Orbitron', monospace; font-size: 14px; font-weight: bold; color: #000; box-shadow: 0 0 10px rgba(6,182,212,0.8);">
                üé• LIVE DEMO
            </div>
        </div>
        <script src="https://player.vimeo.com/api/player.js"></script>

        <!-- Project Description -->
        <div style="background: rgba(0,0,0,0.5); padding: 30px; border-radius: 12px; margin-bottom: 30px;">
            <h3 style="font-size: 32px; color: #a855f7; margin-bottom: 20px;">About BOB</h3>
            <p style="font-size: 18px; line-height: 1.8; color: #e0e6ed; margin-bottom: 20px;">
                BOB is a fully custom-built robot control system featuring real-time FPV camera streaming
                and precision motor control via ESP32 microcontrollers.
            </p>
            <p style="font-size: 18px; line-height: 1.8; color: #e0e6ed; margin-bottom: 20px;">
                The project combines web technologies (Three.js, Flask, Socket.io) with embedded systems programming
                to create a professional robot control interface accessible from any browser.
            </p>

            <h4 style="font-size: 24px; color: #06b6d4; margin-top: 30px; margin-bottom: 15px;">Technical Stack</h4>
            <ul style="font-size: 16px; line-height: 2; color: #e0e6ed; list-style: none;">
                <li>üéÆ <strong>Frontend:</strong> HTML5, CSS3, JavaScript</li>
                <li>üîß <strong>Backend:</strong> Python Flask, Socket.io (WebSocket streaming)</li>
                <li>üìπ <strong>Camera:</strong> ESP32-CAM MJPEG streaming</li>
                <li>‚öôÔ∏è <strong>Motors:</strong> ESP32 with hoverboard motor control</li>
                <li>üéØ <strong>Controls:</strong> WASD keyboard, on-screen buttons, variable speed control</li>
                <li>üí° <strong>Features:</strong> LED control, emergency stop, real-time telemetry</li>
            </ul>
        </div>

        <!-- Photo Gallery -->
        <div style="margin-bottom: 30px;">
            <h3 style="font-size: 32px; color: #a855f7; margin-bottom: 20px;">Hardware Photos</h3>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
                <div style="width: 100%; aspect-ratio: 1; border-radius: 8px; box-shadow: 0 0 20px rgba(168,85,247,0.3); background: linear-gradient(135deg, rgba(168,85,247,0.2), rgba(139,92,246,0.2)); display:flex; align-items:center; justify-content:center; color:#a855f7; font-size:48px;">üì∑</div>
                <div style="width: 100%; aspect-ratio: 1; border-radius: 8px; box-shadow: 0 0 20px rgba(168,85,247,0.3); background: linear-gradient(135deg, rgba(168,85,247,0.2), rgba(139,92,246,0.2)); display:flex; align-items:center; justify-content:center; color:#a855f7; font-size:48px;">üì∑</div>
                <div style="width: 100%; aspect-ratio: 1; border-radius: 8px; box-shadow: 0 0 20px rgba(168,85,247,0.3); background: linear-gradient(135deg, rgba(168,85,247,0.2), rgba(139,92,246,0.2)); display:flex; align-items:center; justify-content:center; color:#a855f7; font-size:48px;">üì∑</div>
                <div style="width: 100%; aspect-ratio: 1; border-radius: 8px; box-shadow: 0 0 20px rgba(168,85,247,0.3); background: linear-gradient(135deg, rgba(168,85,247,0.2), rgba(139,92,246,0.2)); display:flex; align-items:center; justify-content:center; color:#a855f7; font-size:48px;">üì∑</div>
                <!-- Original images commented out until assets are added
                <img src="assets/IMG_5655 2.jpg" style="width: 100%; border-radius: 8px; box-shadow: 0 0 20px rgba(168,85,247,0.3);">
                <img src="assets/IMG_5656 2.jpg" style="width: 100%; border-radius: 8px; box-shadow: 0 0 20px rgba(168,85,247,0.3);">
                <img src="assets/IMG_5659 2.jpg" style="width: 100%; border-radius: 8px; box-shadow: 0 0 20px rgba(168,85,247,0.3);">
                <img src="assets/IMG_5660 2.jpg" style="width: 100%; border-radius: 8px; box-shadow: 0 0 20px rgba(168,85,247,0.3);">
                -->
            </div>
        </div>

        <!-- Source Code Links -->
        <div style="background: rgba(0,0,0,0.5); padding: 30px; border-radius: 12px;">
            <h3 style="font-size: 32px; color: #10b981; margin-bottom: 20px;">üìÇ Source Code & Documentation</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <a href="https://github.com/wjb000/bob-control/blob/main/index.html" target="_blank"
                    style="padding: 20px; background: rgba(255,215,0,0.2); border: 2px solid #ffd700; border-radius: 10px; text-decoration: none; color: #ffd700; font-size: 18px; font-weight: bold; text-align: center; transition: all 0.3s;">
                    üíª Robot Dashboard Code
                </a>
                <a href="https://github.com/wjb000/bob-control/blob/main/MOTORCONTROLS%20copy.TXT" target="_blank"
                    style="padding: 20px; background: rgba(239,68,68,0.2); border: 2px solid #ef4444; border-radius: 10px; text-decoration: none; color: #ef4444; font-size: 18px; font-weight: bold; text-align: center; transition: all 0.3s;">
                    ‚öôÔ∏è Motor ESP32 Code
                </a>
                <a href="https://github.com/wjb000/bob-control/blob/main/GOOUUUCAMERA%20copy.TXT" target="_blank"
                    style="padding: 20px; background: rgba(168,85,247,0.2); border: 2px solid #a855f7; border-radius: 10px; text-decoration: none; color: #a855f7; font-size: 18px; font-weight: bold; text-align: center; transition: all 0.3s;">
                    üìπ Camera ESP32 Code
                </a>
                <a href="https://github.com/wjb000/bob-control/blob/main/pi5%20copy.txt" target="_blank"
                    style="padding: 20px; background: rgba(16,185,129,0.2); border: 2px solid #10b981; border-radius: 10px; text-decoration: none; color: #10b981; font-size: 18px; font-weight: bold; text-align: center; transition: all 0.3s;">
                    ü•ß Raspberry Pi 5 Code
                </a>
            </div>
            <a href="bob-simulator.html" target="_blank"
                style="display: block; padding: 20px; background: rgba(6,182,212,0.2); border: 2px solid #06b6d4; border-radius: 10px; text-decoration: none; color: #06b6d4; font-size: 18px; font-weight: bold; text-align: center; transition: all 0.3s;">
                üéÆ Try Interactive Simulator
            </a>
        </div>
    </div>

    <script>
        // BOB Project Modal Controls
        const bobProjectModal = document.getElementById('bobProjectModal');
        const closeBobProject = document.getElementById('closeBobProject');

        closeBobProject.addEventListener('click', () => {
            bobProjectModal.classList.remove('visible');
        });
    </script>

    <!-- Single BOB Robot Project Popup -->
    <div id="lootPopupBobProject" class="lootPopup" style="z-index: 9999;">
        <h3>ü§ñ Robot Project</h3>
        <p>BOB Control System</p>
        <button id="openButtonBobProject">VIEW PROJECT</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // Password protection
        // Password screen removed - now using wallet authentication

        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // Loading screen with progress
        const loadingScreen = document.getElementById('loading');
        const loadingText = document.querySelector('.loading-text');

        let loadedAssets = 0;
        const totalAssets = 2; // Character and initial setup

        function updateLoadingProgress() {
            loadedAssets++;
            loadingText.textContent = `LOADING... ${Math.round((loadedAssets / totalAssets) * 100)}%`;
            if (loadedAssets >= totalAssets) {
                setTimeout(() => {
                    loadingScreen.classList.add('hidden');
                }, 500);
            }
        }

        // Scene setup - Black room with neon lighting
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 0, 80);

        // Side walls removed - open black void with particles

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 15);

        // Renderer with enhanced settings
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        // Post-processing
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Enhanced bloom for better visuals
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, // Increased strength
            0.4, // Radius
            0.85 // Threshold
        );
        composer.addPass(bloomPass);

        // Add FXAA anti-aliasing for smoother edges
        const fxaaPass = new ShaderPass(FXAAShader);
        const pixelRatio = renderer.getPixelRatio();
        fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * pixelRatio);
        fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * pixelRatio);
        composer.addPass(fxaaPass);

        // Enhanced lighting for black room
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemisphereLight);

        // Main directional light - fixed overhead position
        const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
        mainLight.position.set(0, 80, 10);
        mainLight.castShadow = true;
        mainLight.shadow.camera.left = -70;
        mainLight.shadow.camera.right = 70;
        mainLight.shadow.camera.top = 70;
        mainLight.shadow.camera.bottom = -70;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.bias = -0.0001;
        scene.add(mainLight);

        // Corner accent lights
        const neonLight1 = new THREE.PointLight(0xff00ff, 3, 60);
        neonLight1.position.set(40, 10, 40);
        scene.add(neonLight1);

        const neonLight2 = new THREE.PointLight(0x00ffff, 3, 60);
        neonLight2.position.set(-40, 10, -40);
        scene.add(neonLight2);

        const neonLight3 = new THREE.PointLight(0xff3366, 3, 60);
        neonLight3.position.set(-40, 10, 40);
        scene.add(neonLight3);

        const neonLight4 = new THREE.PointLight(0x00ff88, 3, 60);
        neonLight4.position.set(40, 10, -40);
        scene.add(neonLight4);

        // Create circular platform with cyberpunk texture
        const platformRadius = 37.5;

        // Create super cool spaceship floor texture
        const textureCanvas = document.createElement('canvas');
        textureCanvas.width = 2048;
        textureCanvas.height = 2048;
        const texCtx = textureCanvas.getContext('2d');

        // Sleek dark base with blue glow
        const bgGradient = texCtx.createRadialGradient(1024, 1024, 0, 1024, 1024, 1024);
        bgGradient.addColorStop(0, '#1a2a3a');
        bgGradient.addColorStop(0.5, '#0f1520');
        bgGradient.addColorStop(1, '#050a10');
        texCtx.fillStyle = bgGradient;
        texCtx.fillRect(0, 0, 2048, 2048);

        // Draw futuristic hexagonal tiles
        const hexSize = 60;
        const hexHeight = hexSize * Math.sqrt(3);

        for (let row = -2; row < 32; row++) {
            for (let col = -2; col < 32; col++) {
                const x = col * hexSize * 1.5;
                const y = row * hexHeight + (col % 2) * (hexHeight / 2);

                // Draw hexagon
                texCtx.strokeStyle = '#00d9ff';
                texCtx.lineWidth = 2;
                texCtx.globalAlpha = 0.6;
                texCtx.shadowBlur = 10;
                texCtx.shadowColor = '#00d9ff';

                texCtx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const hx = x + Math.cos(angle) * hexSize;
                    const hy = y + Math.sin(angle) * hexSize;
                    if (i === 0) texCtx.moveTo(hx, hy);
                    else texCtx.lineTo(hx, hy);
                }
                texCtx.closePath();
                texCtx.stroke();

                // Add glowing center
                const centerGlow = texCtx.createRadialGradient(x, y, 0, x, y, hexSize * 0.4);
                centerGlow.addColorStop(0, 'rgba(0, 217, 255, 0.3)');
                centerGlow.addColorStop(1, 'rgba(0, 217, 255, 0)');
                texCtx.fillStyle = centerGlow;
                texCtx.fill();
            }
        }

        texCtx.shadowBlur = 0;

        // Draw energy conduits (glowing lines)
        texCtx.strokeStyle = '#00ffaa';
        texCtx.lineWidth = 4;
        texCtx.globalAlpha = 0.8;
        texCtx.shadowBlur = 20;
        texCtx.shadowColor = '#00ffaa';

        // Horizontal energy lines
        for (let y = 200; y < 2048; y += 400) {
            texCtx.beginPath();
            texCtx.moveTo(0, y);
            texCtx.lineTo(2048, y);
            texCtx.stroke();

            // Add energy pulses
            for (let x = 0; x < 2048; x += 150) {
                texCtx.fillStyle = '#00ffaa';
                texCtx.globalAlpha = 0.8;
                texCtx.beginPath();
                texCtx.arc(x, y, 5, 0, Math.PI * 2);
                texCtx.fill();
            }
        }

        // Vertical energy lines
        for (let x = 200; x < 2048; x += 400) {
            texCtx.globalAlpha = 0.8;
            texCtx.beginPath();
            texCtx.moveTo(x, 0);
            texCtx.lineTo(x, 2048);
            texCtx.stroke();

            // Add energy pulses
            for (let y = 0; y < 2048; y += 150) {
                texCtx.fillStyle = '#00ffaa';
                texCtx.beginPath();
                texCtx.arc(x, y, 5, 0, Math.PI * 2);
                texCtx.fill();
            }
        }

        texCtx.shadowBlur = 0;

        // Add scanning lines (tech readout effect)
        texCtx.strokeStyle = '#0099ff';
        texCtx.lineWidth = 1;
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            texCtx.globalAlpha = 0.4;
            texCtx.shadowBlur = 10;
            texCtx.shadowColor = '#0099ff';
            texCtx.beginPath();
            texCtx.moveTo(1024, 1024);
            texCtx.lineTo(1024 + Math.cos(angle) * 900, 1024 + Math.sin(angle) * 900);
            texCtx.stroke();
        }

        // Add tech indicators/lights
        const colors = ['#00ffff', '#ff00ff', '#00ff00', '#ffff00'];
        for (let i = 0; i < 50; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 400 + Math.random() * 500;
            const x = 1024 + Math.cos(angle) * dist;
            const y = 1024 + Math.sin(angle) * dist;
            const color = colors[Math.floor(Math.random() * colors.length)];

            texCtx.fillStyle = color;
            texCtx.globalAlpha = 0.8;
            texCtx.shadowBlur = 15;
            texCtx.shadowColor = color;
            texCtx.beginPath();
            texCtx.arc(x, y, 4, 0, Math.PI * 2);
            texCtx.fill();

            // Small circle around each light
            texCtx.strokeStyle = color;
            texCtx.lineWidth = 1;
            texCtx.globalAlpha = 0.5;
            texCtx.beginPath();
            texCtx.arc(x, y, 10, 0, Math.PI * 2);
            texCtx.stroke();
        }

        // Add data stream lines
        texCtx.strokeStyle = '#00ccff';
        texCtx.lineWidth = 2;
        for (let i = 0; i < 30; i++) {
            const x = Math.random() * 2048;
            const y = Math.random() * 2048;
            const length = Math.random() * 100 + 50;
            const angle = Math.random() * Math.PI * 2;

            texCtx.globalAlpha = 0.4;
            texCtx.shadowBlur = 8;
            texCtx.shadowColor = '#00ccff';
            texCtx.beginPath();
            texCtx.moveTo(x, y);
            texCtx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
            texCtx.stroke();
        }

        texCtx.shadowBlur = 0;

        const floorTexture = new THREE.CanvasTexture(textureCanvas);
        floorTexture.needsUpdate = true;

        // Create flat circular platform with cyberpunk texture
        const platformGeometry = new THREE.CircleGeometry(platformRadius, 64);
        const platformMaterial = new THREE.MeshStandardMaterial({
            map: floorTexture,
            roughness: 0.3,
            metalness: 0.7,
            emissive: new THREE.Color(0x002244),
            emissiveMap: floorTexture,
            emissiveIntensity: 0.5
        });

        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.rotation.x = -Math.PI / 2;
        platform.position.y = 0;
        platform.receiveShadow = true;
        scene.add(platform);

        // Glowing blue ring around the edge
        const ringGeometry = new THREE.RingGeometry(platformRadius - 0.5, platformRadius + 0.5, 64);
        const ringMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ccff,
            emissive: 0x00ccff,
            emissiveIntensity: 1.5,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        });

        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = -Math.PI / 2;
        ring.position.y = 0.1;
        scene.add(ring);

        // Add point lights around the ring for glow effect
        const ringLightCount = 16;
        for (let i = 0; i < ringLightCount; i++) {
            const angle = (i / ringLightCount) * Math.PI * 2;
            const x = Math.cos(angle) * platformRadius;
            const z = Math.sin(angle) * platformRadius;

            const light = new THREE.PointLight(0x00ccff, 0.5, 10);
            light.position.set(x, 0.5, z);
            scene.add(light);
        }

        // Hovering YouTube thumbnail at edge of platform (loot item style)
        const textureLoader = new THREE.TextureLoader();
        const videoThumbnailGroup = new THREE.Group();

        // Create black texture with HELLO WORLD text
        const canvas1 = document.createElement('canvas');
        canvas1.width = 512;
        canvas1.height = 288;
        const ctx1 = canvas1.getContext('2d');
        ctx1.fillStyle = '#000000';
        ctx1.fillRect(0, 0, 512, 288);
        ctx1.fillStyle = '#ffffff';
        ctx1.font = 'bold 48px Arial';
        ctx1.textAlign = 'center';
        ctx1.fillText('HELLO WORLD', 256, 144);
        const thumbnailTexture = new THREE.CanvasTexture(canvas1);
        const thumbnailGeometry = new THREE.PlaneGeometry(4, 2.25); // 16:9 aspect ratio
        const thumbnailMaterial = new THREE.MeshBasicMaterial({
            map: thumbnailTexture,
            side: THREE.DoubleSide,
            transparent: false
        });
        const thumbnailMesh = new THREE.Mesh(thumbnailGeometry, thumbnailMaterial);
        thumbnailMesh.rotation.x = -Math.PI / 2; // Lay flat on ground
        videoThumbnailGroup.add(thumbnailMesh);

        // Add epic glowing border (gold/legendary style)
        const borderGeometry = new THREE.PlaneGeometry(4.4, 2.65);
        const borderMaterial = new THREE.MeshBasicMaterial({
            color: 0xffd700,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        const borderMesh = new THREE.Mesh(borderGeometry, borderMaterial);
        borderMesh.rotation.x = -Math.PI / 2;
        borderMesh.position.y = -0.05;
        videoThumbnailGroup.add(borderMesh);

        // Larger outer glow
        const outerGlowGeometry = new THREE.PlaneGeometry(5.5, 3.5);
        const outerGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xffaa00,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending
        });
        const outerGlowMesh = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
        outerGlowMesh.rotation.x = -Math.PI / 2;
        outerGlowMesh.position.y = -0.1;
        videoThumbnailGroup.add(outerGlowMesh);

        // Label above thumbnail
        const labelCanvas = document.createElement('canvas');
        labelCanvas.width = 512;
        labelCanvas.height = 256;
        const labelCtx = labelCanvas.getContext('2d');

        // Background
        labelCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        labelCtx.fillRect(0, 0, 512, 256);

        // Glowing border
        labelCtx.strokeStyle = '#ffd700';
        labelCtx.lineWidth = 8;
        labelCtx.strokeRect(4, 4, 504, 248);

        // Text with glow
        labelCtx.textAlign = 'center';
        labelCtx.textBaseline = 'middle';
        labelCtx.shadowBlur = 20;
        labelCtx.shadowColor = '#ffd700';
        labelCtx.fillStyle = '#ffd700';
        labelCtx.font = 'bold 40px Arial';
        labelCtx.fillText('HELLO', 256, 110);
        labelCtx.fillText('WORLD', 256, 160);

        const labelTexture = new THREE.CanvasTexture(labelCanvas);
        const labelMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(4, 2),
            new THREE.MeshBasicMaterial({
                map: labelTexture,
                transparent: true,
                side: THREE.DoubleSide
            })
        );
        labelMesh.position.y = 3;
        videoThumbnailGroup.add(labelMesh);

        // Position at edge of platform
        videoThumbnailGroup.position.set(0, 0.5, -28);
        scene.add(videoThumbnailGroup);

        // Add point light for epic glow effect
        const thumbnailLight = new THREE.PointLight(0xffd700, 2, 10);
        thumbnailLight.position.set(0, 1, -28);
        scene.add(thumbnailLight);

        const videoUrl = 'https://www.youtube.com/watch?v=sZDZNAuZfM8';
        const thumbnailPosition = { x: 0, z: -28, radius: 4 };

        // Popup management
        const lootPopup = document.getElementById('lootPopup');
        const openButton = document.getElementById('openButton');

        // Loot box buttons removed - no longer needed
        // openButton.addEventListener('click', () => {
        //     window.open(videoUrl, '_blank');
        // });

        // SECOND LOOT ITEM - Apple Watch SE Teardown (PURPLE/EPIC THEME)
        const videoThumbnailGroup2 = new THREE.Group();

        // Create black texture with HELLO WORLD text
        const canvas2 = document.createElement('canvas');
        canvas2.width = 512;
        canvas2.height = 288;
        const ctx2 = canvas2.getContext('2d');
        ctx2.fillStyle = '#000000';
        ctx2.fillRect(0, 0, 512, 288);
        ctx2.fillStyle = '#ffffff';
        ctx2.font = 'bold 48px Arial';
        ctx2.textAlign = 'center';
        ctx2.fillText('HELLO WORLD', 256, 144);
        const thumbnailTexture2 = new THREE.CanvasTexture(canvas2);
        const thumbnailMesh2 = new THREE.Mesh(thumbnailGeometry.clone(), new THREE.MeshBasicMaterial({
            map: thumbnailTexture2,
            side: THREE.DoubleSide,
            transparent: false
        }));
        thumbnailMesh2.rotation.x = -Math.PI / 2;
        videoThumbnailGroup2.add(thumbnailMesh2);

        // Add purple epic glowing border
        const borderMesh2 = new THREE.Mesh(borderGeometry.clone(), new THREE.MeshBasicMaterial({
            color: 0x9370db,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        }));
        borderMesh2.rotation.x = -Math.PI / 2;
        borderMesh2.position.y = -0.05;
        videoThumbnailGroup2.add(borderMesh2);

        // Purple outer glow
        const outerGlowMesh2 = new THREE.Mesh(outerGlowGeometry.clone(), new THREE.MeshBasicMaterial({
            color: 0x8a2be2,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending
        }));
        outerGlowMesh2.rotation.x = -Math.PI / 2;
        outerGlowMesh2.position.y = -0.1;
        videoThumbnailGroup2.add(outerGlowMesh2);

        // Label for Apple Watch
        const labelCanvas2 = document.createElement('canvas');
        labelCanvas2.width = 512;
        labelCanvas2.height = 256;
        const labelCtx2 = labelCanvas2.getContext('2d');

        labelCtx2.fillStyle = 'rgba(0, 0, 0, 0.8)';
        labelCtx2.fillRect(0, 0, 512, 256);
        labelCtx2.strokeStyle = '#9370db';
        labelCtx2.lineWidth = 8;
        labelCtx2.strokeRect(4, 4, 504, 248);
        labelCtx2.textAlign = 'center';
        labelCtx2.textBaseline = 'middle';
        labelCtx2.shadowBlur = 20;
        labelCtx2.shadowColor = '#9370db';
        labelCtx2.fillStyle = '#9370db';
        labelCtx2.font = 'bold 38px Arial';
        labelCtx2.fillText('HELLO', 256, 110);
        labelCtx2.fillText('WORLD', 256, 160);

        const labelTexture2 = new THREE.CanvasTexture(labelCanvas2);
        const labelMesh2 = new THREE.Mesh(
            new THREE.PlaneGeometry(4, 2),
            new THREE.MeshBasicMaterial({
                map: labelTexture2,
                transparent: true,
                side: THREE.DoubleSide
            })
        );
        labelMesh2.position.y = 3;
        videoThumbnailGroup2.add(labelMesh2);

        // Position at different location on edge
        videoThumbnailGroup2.position.set(-24, 0.5, -18);
        scene.add(videoThumbnailGroup2);

        const thumbnailLight2 = new THREE.PointLight(0x9370db, 2, 10);
        thumbnailLight2.position.set(-24, 1, -18);
        scene.add(thumbnailLight2);

        const videoUrl2 = 'https://www.youtube.com/watch?v=maRxFHxgG7c';
        const thumbnailPosition2 = { x: -24, z: -18, radius: 4 };

        // Second popup management
        const lootPopup2 = document.getElementById('lootPopup2');
        const openButton2 = document.getElementById('openButton2');

        // openButton2.addEventListener('click', () => {
        //     window.open(videoUrl2, '_blank');
        // });

        // AGV LOOT ITEM - Remote Control AGV Project (ORANGE/CORAL THEME)
        const agvGroup = new THREE.Group();

        // Create AGV project canvas texture
        const agvCanvas = document.createElement('canvas');
        agvCanvas.width = 1024;
        agvCanvas.height = 576;
        const agvCtx = agvCanvas.getContext('2d');

        // Dark background with orange gradient
        const agvGradient = agvCtx.createLinearGradient(0, 0, 1024, 576);
        agvGradient.addColorStop(0, '#1a1a1a');
        agvGradient.addColorStop(1, '#2d1810');
        agvCtx.fillStyle = agvGradient;
        agvCtx.fillRect(0, 0, 1024, 576);

        // Orange border
        agvCtx.strokeStyle = '#ff6b35';
        agvCtx.lineWidth = 12;
        agvCtx.strokeRect(6, 6, 1012, 564);

        // AGV icon/symbol
        agvCtx.fillStyle = '#ff6b35';
        agvCtx.font = 'bold 180px Arial';
        agvCtx.textAlign = 'center';
        agvCtx.textBaseline = 'middle';
        agvCtx.shadowBlur = 30;
        agvCtx.shadowColor = '#ff6b35';
        agvCtx.fillText('üöó', 512, 220);

        // Project title
        agvCtx.font = 'bold 52px Arial';
        agvCtx.fillText('REMOTE CONTROL', 512, 400);
        agvCtx.fillText('HELLO WORLD', 512, 470);

        const agvTexture = new THREE.CanvasTexture(agvCanvas);
        const agvMesh = new THREE.Mesh(thumbnailGeometry.clone(), new THREE.MeshBasicMaterial({
            map: agvTexture,
            side: THREE.DoubleSide,
            transparent: false
        }));
        agvMesh.rotation.x = -Math.PI / 2;
        agvGroup.add(agvMesh);

        // Orange glowing border
        const agvBorderMesh = new THREE.Mesh(borderGeometry.clone(), new THREE.MeshBasicMaterial({
            color: 0xff6b35,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        }));
        agvBorderMesh.rotation.x = -Math.PI / 2;
        agvBorderMesh.position.y = -0.05;
        agvGroup.add(agvBorderMesh);

        // Orange outer glow
        const agvOuterGlow = new THREE.Mesh(outerGlowGeometry.clone(), new THREE.MeshBasicMaterial({
            color: 0xff4500,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending
        }));
        agvOuterGlow.rotation.x = -Math.PI / 2;
        agvOuterGlow.position.y = -0.1;
        agvGroup.add(agvOuterGlow);

        // Floating sign for AGV
        const agvLabelCanvas = document.createElement('canvas');
        agvLabelCanvas.width = 512;
        agvLabelCanvas.height = 256;
        const agvLabelCtx = agvLabelCanvas.getContext('2d');

        agvLabelCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        agvLabelCtx.fillRect(0, 0, 512, 256);
        agvLabelCtx.strokeStyle = '#ff6b35';
        agvLabelCtx.lineWidth = 8;
        agvLabelCtx.strokeRect(4, 4, 504, 248);
        agvLabelCtx.textAlign = 'center';
        agvLabelCtx.textBaseline = 'middle';
        agvLabelCtx.shadowBlur = 20;
        agvLabelCtx.shadowColor = '#ff6b35';
        agvLabelCtx.fillStyle = '#ff6b35';
        agvLabelCtx.font = 'bold 32px Arial';
        agvLabelCtx.fillText('REMOTE CONTROL', 256, 90);
        agvLabelCtx.fillText('HELLO WORLD', 256, 140);

        const agvLabelTexture = new THREE.CanvasTexture(agvLabelCanvas);
        const agvLabelMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(4, 2),
            new THREE.MeshBasicMaterial({
                map: agvLabelTexture,
                transparent: true,
                side: THREE.DoubleSide
            })
        );
        agvLabelMesh.position.y = 3;
        agvGroup.add(agvLabelMesh);

        // Position between iPhone and Resume
        agvGroup.position.set(12, 0.5, -23);
        scene.add(agvGroup);

        const agvLight = new THREE.PointLight(0xff6b35, 2, 10);
        agvLight.position.set(12, 1, -23);
        scene.add(agvLight);

        const agvPosition = { x: 12, z: -23, radius: 4 };

        // AGV popup management
        const agvPopup = document.getElementById('agvPopup');
        const agvOpenBtn = document.getElementById('agvOpenBtn');

        // agvOpenBtn.addEventListener('click', () => {
        //     window.open('agv-control.html', '_blank');
        // });

        // THIRD LOOT ITEM - Resume PDF (GREEN/EMERALD THEME)
        const videoThumbnailGroup3 = new THREE.Group();

        // Create resume document texture
        const resumeCanvas = document.createElement('canvas');
        resumeCanvas.width = 1024;
        resumeCanvas.height = 576; // 16:9 aspect ratio
        const resumeCtx = resumeCanvas.getContext('2d');

        // White paper background
        resumeCtx.fillStyle = '#ffffff';
        resumeCtx.fillRect(0, 0, 1024, 576);

        // Add document lines to make it look like a resume
        // Black background with HELLO WORLD
        resumeCtx.fillStyle = '#000000';
        resumeCtx.fillRect(0, 0, 1024, 576);
        resumeCtx.fillStyle = '#ffffff';
        resumeCtx.font = 'bold 72px Arial';
        resumeCtx.textAlign = 'center';
        resumeCtx.fillText('HELLO WORLD', 512, 288);

        const resumeTexture = new THREE.CanvasTexture(resumeCanvas);
        const thumbnailMesh3 = new THREE.Mesh(thumbnailGeometry.clone(), new THREE.MeshBasicMaterial({
            map: resumeTexture,
            side: THREE.DoubleSide,
            transparent: false
        }));
        thumbnailMesh3.rotation.x = -Math.PI / 2;
        videoThumbnailGroup3.add(thumbnailMesh3);

        // Add green emerald glowing border
        const borderMesh3 = new THREE.Mesh(borderGeometry.clone(), new THREE.MeshBasicMaterial({
            color: 0x10b981,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        }));
        borderMesh3.rotation.x = -Math.PI / 2;
        borderMesh3.position.y = -0.05;
        videoThumbnailGroup3.add(borderMesh3);

        // Green outer glow
        const outerGlowMesh3 = new THREE.Mesh(outerGlowGeometry.clone(), new THREE.MeshBasicMaterial({
            color: 0x059669,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending
        }));
        outerGlowMesh3.rotation.x = -Math.PI / 2;
        outerGlowMesh3.position.y = -0.1;
        videoThumbnailGroup3.add(outerGlowMesh3);

        // Label for Resume
        const labelCanvas3 = document.createElement('canvas');
        labelCanvas3.width = 512;
        labelCanvas3.height = 256;
        const labelCtx3 = labelCanvas3.getContext('2d');

        labelCtx3.fillStyle = 'rgba(0, 0, 0, 0.8)';
        labelCtx3.fillRect(0, 0, 512, 256);
        labelCtx3.strokeStyle = '#10b981';
        labelCtx3.lineWidth = 8;
        labelCtx3.strokeRect(4, 4, 504, 248);
        labelCtx3.textAlign = 'center';
        labelCtx3.textBaseline = 'middle';
        labelCtx3.shadowBlur = 20;
        labelCtx3.shadowColor = '#10b981';
        labelCtx3.fillStyle = '#10b981';
        labelCtx3.font = 'bold 38px Arial';
        labelCtx3.fillText('HELLO', 256, 110);
        labelCtx3.fillText('WORLD', 256, 160);

        const labelTexture3 = new THREE.CanvasTexture(labelCanvas3);
        const labelMesh3 = new THREE.Mesh(
            new THREE.PlaneGeometry(4, 2),
            new THREE.MeshBasicMaterial({
                map: labelTexture3,
                transparent: true,
                side: THREE.DoubleSide
            })
        );
        labelMesh3.position.y = 3;
        videoThumbnailGroup3.add(labelMesh3);

        // Position at different location on edge
        videoThumbnailGroup3.position.set(24, 0.5, -18);
        scene.add(videoThumbnailGroup3);

        const thumbnailLight3 = new THREE.PointLight(0x10b981, 2, 10);
        thumbnailLight3.position.set(24, 1, -18);
        scene.add(thumbnailLight3);

        const resumeUrl = 'RESUME2026.pdf';
        const thumbnailPosition3 = { x: 24, z: -18, radius: 4 };

        // Third popup management
        const lootPopup3 = document.getElementById('lootPopup3');
        const openButton3 = document.getElementById('openButton3');

        // openButton3.addEventListener('click', () => {
        //     window.open(resumeUrl, '_blank');
        // });

        // FOURTH LOOT ITEM - GitHub Profile (ORANGE THEME)
        const videoThumbnailGroup4 = new THREE.Group();

        // Create GitHub profile texture
        const githubCanvas = document.createElement('canvas');
        githubCanvas.width = 1024;
        githubCanvas.height = 576; // 16:9 aspect ratio
        const githubCtx = githubCanvas.getContext('2d');

        // Dark GitHub background
        githubCtx.fillStyle = '#0d1117';
        githubCtx.fillRect(0, 0, 1024, 576);

        // GitHub header bar
        githubCtx.fillStyle = '#161b22';
        githubCtx.fillRect(0, 0, 1024, 80);

        // Profile avatar circle
        githubCtx.fillStyle = '#30363d';
        githubCtx.beginPath();
        githubCtx.arc(150, 200, 60, 0, Math.PI * 2);
        githubCtx.fill();

        // Octocat silhouette in avatar
        githubCtx.fillStyle = '#f97316';
        githubCtx.font = 'bold 60px Arial';
        githubCtx.textAlign = 'center';
        githubCtx.textBaseline = 'middle';
        githubCtx.fillText('üêô', 150, 200);

        // Username
        githubCtx.fillStyle = '#c9d1d9';
        githubCtx.font = 'bold 42px Arial';
        githubCtx.textAlign = 'left';
        githubCtx.fillText('wjb000', 240, 180);

        // Bio lines
        githubCtx.fillStyle = '#8b949e';
        githubCtx.font = '24px Arial';
        githubCtx.fillText('Software Developer', 240, 220);

        // Contribution graph bars
        githubCtx.fillStyle = '#f97316';
        for (let i = 0; i < 20; i++) {
            const height = Math.random() * 40 + 10;
            githubCtx.fillRect(50 + i * 45, 330 - height, 35, height);
        }

        // Stats boxes
        githubCtx.fillStyle = '#21262d';
        githubCtx.fillRect(50, 380, 280, 150);
        githubCtx.fillRect(360, 380, 280, 150);
        githubCtx.fillRect(670, 380, 280, 150);

        githubCtx.fillStyle = '#f97316';
        githubCtx.font = 'bold 36px Arial';
        githubCtx.textAlign = 'center';
        githubCtx.fillText('Repos', 190, 430);
        githubCtx.fillText('Stars', 500, 430);
        githubCtx.fillText('Projects', 810, 430);

        // GitHub logo/text
        githubCtx.fillStyle = '#f97316';
        githubCtx.font = 'bold 48px Arial';
        githubCtx.textAlign = 'center';
        githubCtx.fillText('GITHUB', 512, 50);

        const githubTexture = new THREE.CanvasTexture(githubCanvas);
        const thumbnailMesh4 = new THREE.Mesh(thumbnailGeometry.clone(), new THREE.MeshBasicMaterial({
            map: githubTexture,
            side: THREE.DoubleSide,
            transparent: false
        }));
        thumbnailMesh4.rotation.x = -Math.PI / 2;
        videoThumbnailGroup4.add(thumbnailMesh4);

        // Add orange glowing border
        const borderMesh4 = new THREE.Mesh(borderGeometry.clone(), new THREE.MeshBasicMaterial({
            color: 0xf97316,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        }));
        borderMesh4.rotation.x = -Math.PI / 2;
        borderMesh4.position.y = -0.05;
        videoThumbnailGroup4.add(borderMesh4);

        // Orange outer glow
        const outerGlowMesh4 = new THREE.Mesh(outerGlowGeometry.clone(), new THREE.MeshBasicMaterial({
            color: 0xea580c,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending
        }));
        outerGlowMesh4.rotation.x = -Math.PI / 2;
        outerGlowMesh4.position.y = -0.1;
        videoThumbnailGroup4.add(outerGlowMesh4);

        // Label for GitHub
        const labelCanvas4 = document.createElement('canvas');
        labelCanvas4.width = 512;
        labelCanvas4.height = 256;
        const labelCtx4 = labelCanvas4.getContext('2d');

        labelCtx4.fillStyle = 'rgba(0, 0, 0, 0.8)';
        labelCtx4.fillRect(0, 0, 512, 256);
        labelCtx4.strokeStyle = '#f97316';
        labelCtx4.lineWidth = 8;
        labelCtx4.strokeRect(4, 4, 504, 248);
        labelCtx4.textAlign = 'center';
        labelCtx4.textBaseline = 'middle';
        labelCtx4.shadowBlur = 20;
        labelCtx4.shadowColor = '#f97316';
        labelCtx4.fillStyle = '#f97316';
        labelCtx4.font = 'bold 38px Arial';
        labelCtx4.fillText('HELLO', 256, 110);
        labelCtx4.fillText('WORLD', 256, 160);

        const labelTexture4 = new THREE.CanvasTexture(labelCanvas4);
        const labelMesh4 = new THREE.Mesh(
            new THREE.PlaneGeometry(4, 2),
            new THREE.MeshBasicMaterial({
                map: labelTexture4,
                transparent: true,
                side: THREE.DoubleSide
            })
        );
        labelMesh4.position.y = 3;
        videoThumbnailGroup4.add(labelMesh4);

        // Position at different location on edge (to the right of resume)
        videoThumbnailGroup4.position.set(28, 0.5, -8);
        scene.add(videoThumbnailGroup4);

        const thumbnailLight4 = new THREE.PointLight(0xf97316, 2, 10);
        thumbnailLight4.position.set(28, 1, -8);
        scene.add(thumbnailLight4);

        const githubUrl = 'https://github.com/wjb000';
        const thumbnailPosition4 = { x: 28, z: -8, radius: 4 };

        // Fourth popup management
        const lootPopup4 = document.getElementById('lootPopup4');
        const openButton4 = document.getElementById('openButton4');

        // openButton4.addEventListener('click', () => {
        //     window.open(githubUrl, '_blank');
        // });

        // ========== BOB ROBOT PROJECT LOOT BOX (BLUE) ==========

        const bobProjectGroup = new THREE.Group();

        const bobProjectCanvas = document.createElement('canvas');
        bobProjectCanvas.width = 1024;
        bobProjectCanvas.height = 576;
        const bobProjectCtx = bobProjectCanvas.getContext('2d');

        // Blue gradient background
        const bobGradient = bobProjectCtx.createLinearGradient(0, 0, 1024, 576);
        bobGradient.addColorStop(0, '#0a1929');
        bobGradient.addColorStop(1, '#0c2340');
        bobProjectCtx.fillStyle = bobGradient;
        bobProjectCtx.fillRect(0, 0, 1024, 576);

        bobProjectCtx.fillStyle = '#06b6d4';
        bobProjectCtx.font = 'bold 72px Arial';
        bobProjectCtx.textAlign = 'center';
        bobProjectCtx.textBaseline = 'middle';
        bobProjectCtx.fillText('ü§ñ', 512, 200);
        bobProjectCtx.font = 'bold 60px Arial';
        bobProjectCtx.fillText('HELLO WORLD', 512, 340);
        bobProjectCtx.font = 'bold 42px Arial';
        bobProjectCtx.fillText('HELLO WORLD', 512, 410);
        bobProjectCtx.font = '32px Arial';
        bobProjectCtx.fillStyle = '#67e8f9';
        bobProjectCtx.fillText('VIEW PROJECT', 512, 480);

        const bobProjectTexture = new THREE.CanvasTexture(bobProjectCanvas);
        const bobProjectMesh = new THREE.Mesh(thumbnailGeometry.clone(), new THREE.MeshBasicMaterial({
            map: bobProjectTexture,
            side: THREE.DoubleSide
        }));
        bobProjectMesh.rotation.x = -Math.PI / 2;
        bobProjectGroup.add(bobProjectMesh);

        const bobProjectBorder = new THREE.Mesh(borderGeometry.clone(), new THREE.MeshBasicMaterial({
            color: 0x06b6d4,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        }));
        bobProjectBorder.rotation.x = -Math.PI / 2;
        bobProjectBorder.position.y = -0.05;
        bobProjectGroup.add(bobProjectBorder);

        const bobProjectGlow = new THREE.Mesh(outerGlowGeometry.clone(), new THREE.MeshBasicMaterial({
            color: 0x0891b2,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending
        }));
        bobProjectGlow.rotation.x = -Math.PI / 2;
        bobProjectGlow.position.y = -0.1;
        bobProjectGroup.add(bobProjectGlow);

        // Label above BOB project
        const bobLabelCanvas = document.createElement('canvas');
        bobLabelCanvas.width = 512;
        bobLabelCanvas.height = 256;
        const bobLabelCtx = bobLabelCanvas.getContext('2d');

        bobLabelCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        bobLabelCtx.fillRect(0, 0, 512, 256);

        bobLabelCtx.strokeStyle = '#06b6d4';
        bobLabelCtx.lineWidth = 8;
        bobLabelCtx.strokeRect(4, 4, 504, 248);

        bobLabelCtx.textAlign = 'center';
        bobLabelCtx.textBaseline = 'middle';
        bobLabelCtx.shadowBlur = 20;
        bobLabelCtx.shadowColor = '#06b6d4';
        bobLabelCtx.fillStyle = '#06b6d4';
        bobLabelCtx.font = 'bold 50px Arial';
        bobLabelCtx.fillText('HELLO WORLD', 256, 128);
        bobLabelCtx.fillText('PROJECT', 256, 168);

        const bobLabelTexture = new THREE.CanvasTexture(bobLabelCanvas);
        const bobLabelMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(4, 2),
            new THREE.MeshBasicMaterial({
                map: bobLabelTexture,
                transparent: true,
                side: THREE.DoubleSide
            })
        );
        bobLabelMesh.position.y = 3.5;
        bobLabelMesh.rotation.y = 0;
        bobProjectGroup.add(bobLabelMesh);

        bobProjectGroup.position.set(-12, 0.5, -23);
        scene.add(bobProjectGroup);

        const bobProjectLight = new THREE.PointLight(0x06b6d4, 2, 10);
        bobProjectLight.position.set(-12, 1, -23);
        scene.add(bobProjectLight);

        const bobProjectPosition = { x: -12, z: -23, radius: 4 };
        const lootPopupBobProject = document.getElementById('lootPopupBobProject');
        const openButtonBobProject = document.getElementById('openButtonBobProject');

        // openButtonBobProject.addEventListener('click', () => {
        //     window.open('robot-project.html', '_blank');
        // });

        // COVER LETTER LOOT ITEM (PINK/MAGENTA THEME)
        const coverLetterGroup = new THREE.Group();

        // Create cover letter document canvas
        const coverLetterCanvas = document.createElement('canvas');
        coverLetterCanvas.width = 1024;
        coverLetterCanvas.height = 576;
        const coverLetterCtx = coverLetterCanvas.getContext('2d');

        // Pink gradient background
        const coverGradient = coverLetterCtx.createLinearGradient(0, 0, 1024, 576);
        coverGradient.addColorStop(0, '#1a1a1a');
        coverGradient.addColorStop(1, '#2d1828');
        coverLetterCtx.fillStyle = coverGradient;
        coverLetterCtx.fillRect(0, 0, 1024, 576);

        // Pink border
        coverLetterCtx.strokeStyle = '#e91e63';
        coverLetterCtx.lineWidth = 12;
        coverLetterCtx.strokeRect(6, 6, 1012, 564);

        // Document icon
        coverLetterCtx.fillStyle = '#e91e63';
        coverLetterCtx.font = 'bold 180px Arial';
        coverLetterCtx.textAlign = 'center';
        coverLetterCtx.textBaseline = 'middle';
        coverLetterCtx.shadowBlur = 30;
        coverLetterCtx.shadowColor = '#e91e63';
        coverLetterCtx.fillText('üìÑ', 512, 220);

        // Title
        coverLetterCtx.font = 'bold 56px Arial';
        coverLetterCtx.fillText('HELLO WORLD', 512, 390);
        coverLetterCtx.fillText('LETTER', 512, 460);

        const coverLetterTexture = new THREE.CanvasTexture(coverLetterCanvas);
        const coverLetterMesh = new THREE.Mesh(thumbnailGeometry.clone(), new THREE.MeshBasicMaterial({
            map: coverLetterTexture,
            side: THREE.DoubleSide
        }));
        coverLetterMesh.rotation.x = -Math.PI / 2;
        coverLetterGroup.add(coverLetterMesh);

        // Pink glowing border
        const coverBorderMesh = new THREE.Mesh(borderGeometry.clone(), new THREE.MeshBasicMaterial({
            color: 0xe91e63,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        }));
        coverBorderMesh.rotation.x = -Math.PI / 2;
        coverBorderMesh.position.y = -0.05;
        coverLetterGroup.add(coverBorderMesh);

        // Pink outer glow
        const coverOuterGlow = new THREE.Mesh(outerGlowGeometry.clone(), new THREE.MeshBasicMaterial({
            color: 0xc2185b,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending
        }));
        coverOuterGlow.rotation.x = -Math.PI / 2;
        coverOuterGlow.position.y = -0.1;
        coverLetterGroup.add(coverOuterGlow);

        // Floating sign for Cover Letter
        const coverLabelCanvas = document.createElement('canvas');
        coverLabelCanvas.width = 512;
        coverLabelCanvas.height = 256;
        const coverLabelCtx = coverLabelCanvas.getContext('2d');

        coverLabelCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        coverLabelCtx.fillRect(0, 0, 512, 256);
        coverLabelCtx.strokeStyle = '#e91e63';
        coverLabelCtx.lineWidth = 8;
        coverLabelCtx.strokeRect(4, 4, 504, 248);
        coverLabelCtx.textAlign = 'center';
        coverLabelCtx.textBaseline = 'middle';
        coverLabelCtx.shadowBlur = 20;
        coverLabelCtx.shadowColor = '#e91e63';
        coverLabelCtx.fillStyle = '#e91e63';
        coverLabelCtx.font = 'bold 48px Arial';
        coverLabelCtx.fillText('HELLO WORLD', 256, 128);
        coverLabelCtx.fillText('LETTER', 256, 165);

        const coverLabelTexture = new THREE.CanvasTexture(coverLabelCanvas);
        const coverLabelMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(4, 2),
            new THREE.MeshBasicMaterial({
                map: coverLabelTexture,
                transparent: true,
                side: THREE.DoubleSide
            })
        );
        coverLabelMesh.position.y = 3;
        coverLetterGroup.add(coverLabelMesh);

        // Position to the left of Apple Watch
        coverLetterGroup.position.set(-30, 0.5, -12);
        scene.add(coverLetterGroup);

        const coverLetterLight = new THREE.PointLight(0xe91e63, 2, 10);
        coverLetterLight.position.set(-30, 1, -12);
        scene.add(coverLetterLight);

        const coverLetterPosition = { x: -30, z: -12, radius: 4 };

        // Cover Letter popup management
        const coverLetterPopup = document.getElementById('coverLetterPopup');
        const openButtonCoverLetter = document.getElementById('openButtonCoverLetter');

        // openButtonCoverLetter.addEventListener('click', () => {
        //     window.open('Cover Letter.pdf', '_blank');
        // });

        // Player character container
        const playerGroup = new THREE.Group();
        let playerModel = null;
        let playerMixer = null;
        let walkAction = null;
        let idleAction = null;
        let runAction = null;
        let playerBody = null;
        let currentCharacter = 'robot';
        scene.add(playerGroup);

        // Robot model URL
        const robotModel = {
            url: 'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
            scale: 0.75,
            rotation: 0
        };

        // Initialize GLTF loader
        const loader = new GLTFLoader();

        // Load robot character
        loader.load(
            robotModel.url,
            (gltf) => {
                playerModel = gltf.scene;
                playerModel.scale.set(robotModel.scale, robotModel.scale, robotModel.scale);
                playerModel.rotation.y = robotModel.rotation;

                // Enable shadows and apply blue accents
                playerModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        if (child.material) {
                            // Change orange/red accents to cyan blue (#00ccff)
                            if (child.material.color) {
                                const currentColor = child.material.color;
                                // If color has red/orange tones, replace with blue
                                if (currentColor.r > 0.5 && currentColor.g < 0.5) {
                                    child.material.color = new THREE.Color(0x00ccff);
                                    child.material.emissive = new THREE.Color(0x0088cc);
                                    child.material.emissiveIntensity = 0.3;
                                }
                            }
                        }
                    }
                });

                playerGroup.add(playerModel);
                playerBody = playerModel;

                // Setup animations with full configuration
                if (gltf.animations && gltf.animations.length) {
                    playerMixer = new THREE.AnimationMixer(playerModel);

                    walkAction = null;
                    idleAction = null;
                    runAction = null;

                    console.log('Available animations:', gltf.animations.map(a => a.name));

                    // Find and configure all animations
                    gltf.animations.forEach((clip) => {
                        const name = clip.name.toLowerCase();
                        const action = playerMixer.clipAction(clip);

                        // Critical: Set loop mode to repeat
                        action.setLoop(THREE.LoopRepeat);
                        action.clampWhenFinished = false;
                        action.enable = true;

                        // Set timing
                        action.timeScale = 1;
                        action.time = 0;

                        if (name.includes('walk')) {
                            walkAction = action;
                            console.log('Found walk animation:', clip.name);
                        } else if (name.includes('idle')) {
                            idleAction = action;
                            console.log('Found idle animation:', clip.name);
                        } else if (name.includes('run')) {
                            runAction = action;
                            console.log('Found run animation:', clip.name);
                        }
                    });

                    // Start with idle animation looping
                    if (idleAction) {
                        idleAction.reset();
                        idleAction.setEffectiveWeight(1);
                        idleAction.play();
                    }

                    console.log('Animation setup complete:', {
                        walk: !!walkAction,
                        idle: !!idleAction,
                        run: !!runAction
                    });
                }

                updateLoadingProgress();
                console.log('Robot loaded!');
            },
            (progress) => {
                console.log('Loading character:', (progress.loaded / progress.total * 100) + '%');
            },
            (error) => {
                console.error('Error loading character:', error);
                // Fallback
                const fallbackGeo = new THREE.CapsuleGeometry(0.5, 1.5, 8, 16);
                const fallbackMat = new THREE.MeshStandardMaterial({
                    color: 0x00ffff,
                    emissive: 0x0066ff,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2
                });
                playerBody = new THREE.Mesh(fallbackGeo, fallbackMat);
                playerBody.castShadow = true;
                playerBody.position.y = 1;
                playerGroup.add(playerBody);
                updateLoadingProgress();
            }
        );

        playerGroup.position.set(0, 0, 0);

        // Collision objects array
        const collisionObjects = [];
        const buildingModels = [];

        // Load sci-fi city buildings
        function loadBuilding(x, z, scale, rotation = 0) {
            loader.load(
                'https://threejs.org/examples/models/gltf/LittlestTokyo.glb',
                (gltf) => {
                    const building = gltf.scene;
                    building.scale.set(scale * 0.01, scale * 0.01, scale * 0.01);
                    building.position.set(x, 0, z);
                    building.rotation.y = rotation;

                    building.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    scene.add(building);
                    buildingModels.push(building);

                    // Add collision
                    collisionObjects.push({ x, z, radius: scale * 5 });
                },
                undefined,
                (error) => {
                    console.log('Building load error - skipping fallback cubes');
                    // Don't add fallback buildings - user doesn't want black cubes
                }
            );
        }

        // Add sci-fi city buildings in a circle
        const buildingPositions = [
            { x: 30, z: 30, scale: 3, rotation: 0 },
            { x: -30, z: 30, scale: 3, rotation: Math.PI / 2 },
            { x: 30, z: -30, scale: 3, rotation: Math.PI },
            { x: -30, z: -30, scale: 3, rotation: -Math.PI / 2 },
            { x: 50, z: 0, scale: 4, rotation: 0 },
            { x: -50, z: 0, scale: 4, rotation: 0 },
            { x: 0, z: 50, scale: 4, rotation: Math.PI / 4 },
            { x: 0, z: -50, scale: 4, rotation: -Math.PI / 4 }
        ];

        buildingPositions.forEach(pos => {
            loadBuilding(pos.x, pos.z, pos.scale, pos.rotation);
        });

        // Floating platforms removed - were covering characters

        // Glowing cubes removed per user request
        const crystals = [];

        // Add atmospheric particle system
        const particleCount = 500;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleVelocities = [];

        for (let i = 0; i < particleCount; i++) {
            particlePositions[i * 3] = (Math.random() - 0.5) * 80;
            particlePositions[i * 3 + 1] = Math.random() * 50;
            particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 80;

            particleVelocities.push({
                x: (Math.random() - 0.5) * 0.02,
                y: (Math.random() - 0.5) * 0.02,
                z: (Math.random() - 0.5) * 0.02
            });
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

        const particleMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particleSystem);

        // Environment loaded (buildings load asynchronously)
        updateLoadingProgress();

        // Normal movement system with sprint
        const keys = { w: false, a: false, s: false, d: false, shift: false, space: false };
        const moveSpeed = 0.15;
        const sprintMultiplier = 2;
        const playerVelocity = new THREE.Vector3();

        // Jump system
        let isJumping = false;
        let verticalVelocity = 0;
        const jumpStrength = 0.35;
        const gravity = 0.015;
        const groundLevel = 0;

        // Position player on platform
        // Check spawn position based on which room player is returning from
        const spawnPosition = sessionStorage.getItem('spawnPosition');
        if (spawnPosition === 'fromRoom2') {
            // Spawn player away from electronics portal (center of circle)
            playerGroup.position.set(0, 0, 5);
            sessionStorage.removeItem('spawnPosition');
        } else if (spawnPosition === 'fromRoom3') {
            // Spawn player away from technical skills portal (opposite direction)
            const spawnAngle = (120 * Math.PI) / 180 + Math.PI;
            playerGroup.position.set(Math.sin(spawnAngle) * 10, 0, Math.cos(spawnAngle) * 10);
            sessionStorage.removeItem('spawnPosition');
        } else if (spawnPosition === 'fromRoom4') {
            // Spawn player away from job experience portal (opposite direction)
            const spawnAngle = (240 * Math.PI) / 180 + Math.PI;
            playerGroup.position.set(Math.sin(spawnAngle) * 10, 0, Math.cos(spawnAngle) * 10);
            sessionStorage.removeItem('spawnPosition');
        } else {
            // Normal spawn in center
            playerGroup.position.set(0, 0, 0);
        }

        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
            }
            if (e.key === 'Shift') keys.shift = true;
            if (e.key === ' ' && !isJumping) {
                keys.space = true;
                isJumping = true;
                verticalVelocity = jumpStrength;
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
            if (e.key === 'Shift') keys.shift = false;
            if (e.key === ' ') keys.space = false;
        });

        // Mobile joystick with improved handling
        const joystick = document.getElementById('joystick');
        const joystickKnob = document.getElementById('joystick-knob');
        let joystickActive = false;
        let joystickVector = { x: 0, y: 0 };

        function handleTouch(e) {
            e.preventDefault();
            if (e.type === 'touchstart' || e.type === 'touchmove') {
                joystickActive = true;
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 3;

                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }

                joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

                joystickVector.x = deltaX / maxDistance;
                joystickVector.y = deltaY / maxDistance;
            } else if (e.type === 'touchend' || e.type === 'touchcancel') {
                joystickActive = false;
                joystickKnob.style.transform = 'translate(-50%, -50%)';
                joystickVector.x = 0;
                joystickVector.y = 0;
            }
        }

        joystick.addEventListener('touchstart', handleTouch, { passive: false });
        joystick.addEventListener('touchmove', handleTouch, { passive: false });
        joystick.addEventListener('touchend', handleTouch, { passive: false });
        joystick.addEventListener('touchcancel', handleTouch, { passive: false });

        // Collision detection
        function checkCollision(newX, newZ) {
            for (const obj of collisionObjects) {
                const dx = newX - obj.x;
                const dz = newZ - obj.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < obj.radius + 1) {
                    return true;
                }
            }
            return false;
        }

        // Performance tracking
        let lastTime = performance.now();
        let frames = 0;
        let fps = 60;
        const clock = new THREE.Clock();

        // Configuration
        const CONFIG = {
            // Supabase Backend
            SUPABASE_URL: 'https://qrbayufbmcxqjesbmpad.supabase.co',
            SUPABASE_ANON_KEY: 'sb_publishable_we4uqlRpjzLHsvAx802Nkg_-oeQzNTe',

            // Solana RPC Configuration (Helius - 100k requests/day)
            SOLANA_RPC_PRIMARY: 'https://mainnet.helius-rpc.com/?api-key=d2c933e5-1960-4638-9646-5f86aa75006c',
            SOLANA_RPC_FALLBACK: 'https://api.mainnet-beta.solana.com',

            // Proximity Settings
            PROXIMITY_RANGE: 50,
            POSITION_UPDATE_INTERVAL: 50,
            HEARTBEAT_INTERVAL: 5000,
            CHAT_UPDATE_INTERVAL: 3000
        };

        // Initialize Supabase Client
        const supabaseClient = createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_ANON_KEY);

async function supabaseRetry(operation, maxRetries = 3, delay = 2000) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      console.error(`Supabase operation failed (attempt ${attempt}):`, error);
      if (attempt === maxRetries) {
        showError('Connection error: ' + error.message);
        throw error;
      }
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Function to show error UI
function showError(msg) {
  const errorDiv = document.getElementById('errorMessage');
  if (!errorDiv) {
    const newDiv = document.createElement('div');
    newDiv.id = 'errorMessage';
    newDiv.style.position = 'fixed';
    newDiv.style.top = '10px';
    newDiv.style.left = '50%';
    newDiv.style.transform = 'translateX(-50%)';
    newDiv.style.background = 'rgba(255, 0, 0, 0.8)';
    newDiv.style.color = 'white';
    newDiv.style.padding = '10px 20px';
    newDiv.style.borderRadius = '5px';
    newDiv.style.zIndex = '1000';
    newDiv.style.display = 'none';
    document.body.appendChild(newDiv);
  }
  errorDiv.textContent = msg;
  errorDiv.style.display = 'block';
  setTimeout(() => { errorDiv.style.display = 'none'; }, 5000);
}

// P2P (WebRTC) Setup
const peers = new Map(); // peerId -> RTCPeerConnection
const dataChannels = new Map(); // peerId -> RTCDataChannel

async function initiateP2P(peerId) {
  if (peers.has(peerId)) return;

  const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
  peers.set(peerId, pc);

  const channel = pc.createDataChannel('gameData');
  channel.onopen = () => console.log(`P2P open with ${peerId}`);
  channel.onmessage = (e) => handleP2PData(peerId, JSON.parse(e.data));
  dataChannels.set(peerId, channel);

  pc.onicecandidate = (e) => {
    if (e.candidate) {
      signalingServer.send(JSON.stringify({ from: myPlayerId, to: peerId, type: 'candidate', data: e.candidate }));
    }
  };

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  signalingServer.send(JSON.stringify({ from: myPlayerId, to: peerId, type: 'offer', data: offer }));

  // Handle incoming answer/candidate (via subscription)
}

function handleP2PData(peerId, msg) {
  if (msg.type === 'position') {
    updateOtherPlayer(peerId, msg.position, msg.rotation);
    const player = otherPlayers.get(peerId);
    if (player) player.lastUpdate = Date.now();
  } else if (msg.type === 'chat') {
    const dx = msg.pos_x - playerGroup.position.x;
    const dz = msg.pos_z - playerGroup.position.z;
    if (Math.sqrt(dx*dx + dz*dz) <= CONFIG.PROXIMITY_RANGE) {
      const chatMessages = document.getElementById('chatMessages');
      const msgDiv = document.createElement('div');
      msgDiv.innerHTML = `<span style="color: #55FF55;">${msg.username}</span>: ${msg.message}`;
      chatMessages.appendChild(msgDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
  } else if (msg.type === 'requestPosition') {
    dataChannels.get(peerId).send(JSON.stringify({
      type: 'position',
      position: { x: playerGroup.position.x, y: playerGroup.position.y, z: playerGroup.position.z },
      rotation: playerGroup.rotation.y
    }));
  }
}

function sendP2PPosition() {
  dataChannels.forEach((channel, peerId) => {
    if (channel.readyState === 'open') {
      channel.send(JSON.stringify({
        type: 'position',
        position: { x: playerGroup.position.x, y: playerGroup.position.y, z: playerGroup.position.z },
        rotation: playerGroup.rotation.y
      }));
    }
  });
}

function sendP2PChat(text) {
  dataChannels.forEach((channel, peerId) => {
    if (channel.readyState === 'open') {
      channel.send(JSON.stringify({
        type: 'chat',
        username: walletAddress.slice(0,6) + '...' + walletAddress.slice(-4),
        message: text,
        pos_x: playerGroup.position.x,
        pos_z: playerGroup.position.z
      }));
    }
  });
}

// Subscribe to signals for P2P signaling
function subscribeToSignals() {
  supabaseClient.channel('signals').on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'signals' }, async (payload) => {
    const signal = payload.new;
    if (signal.to !== myPlayerId) return;

    let pc = peers.get(signal.from);
    if (!pc) {
      pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
      peers.set(signal.from, pc);
      pc.ondatachannel = (e) => {
        const channel = e.channel;
        channel.onmessage = (ev) => handleP2PData(signal.from, JSON.parse(ev.data));
        dataChannels.set(signal.from, channel);
      };
    }

    if (signal.type === 'offer') {
      await pc.setRemoteDescription(signal.data);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await supabaseRetry(() => supabaseClient.from('signals').insert([{ from: myPlayerId, to: signal.from, type: 'answer', data: answer }]));
    } else if (signal.type === 'answer') {
      await pc.setRemoteDescription(signal.data);
    } else if (signal.type === 'candidate') {
      await pc.addIceCandidate(signal.data);
    }
  }).subscribe();
}


        // Wallet State
        let walletConnected = false;
        let walletAddress = null;
        let walletType = null;
        let walletBalance = 0;

        // Multiplayer System
        const otherPlayers = new Map();
        let myPlayerId = null;
        let myColor = '#00ff41'; // Default color
        let updateInterval = null;
        let heartbeatInterval = null;
        let chatUpdateInterval = null;

        // Wallet Connection Functions
        async function connectPhantom() {
            try {
                const { solana } = window;

                if (!solana?.isPhantom) {
                    alert('Please install Phantom wallet!\n\nVisit: https://phantom.app/');
                    window.open('https://phantom.app/', '_blank');
                    return;
                }

                const response = await solana.connect();
                if (!response?.publicKey) {
                    throw new Error('Failed to get public key from Phantom');
                }

                walletAddress = response.publicKey.toString();
                walletType = 'phantom';
                walletConnected = true;

                console.log('Phantom connected:', walletAddress);

                // Try to fetch balance with fallback RPC
                let balance = 0;
                const rpcEndpoints = [CONFIG.SOLANA_RPC_PRIMARY, CONFIG.SOLANA_RPC_FALLBACK];

                for (const endpoint of rpcEndpoints) {
                    try {
                        console.log(`Fetching balance from: ${endpoint}`);
                        const connection = new solanaWeb3.Connection(endpoint, 'confirmed');
                        balance = await connection.getBalance(response.publicKey);
                        walletBalance = (balance / solanaWeb3.LAMPORTS_PER_SOL).toFixed(4);
                        console.log(`Balance fetched successfully: ${walletBalance} SOL`);
                        break;
                    } catch (err) {
                        console.warn(`RPC ${endpoint} failed:`, err);
                        if (endpoint === rpcEndpoints[rpcEndpoints.length - 1]) {
                            walletBalance = 0;
                        }
                    }
                }

                onWalletConnected();

            } catch (error) {
                console.error('Phantom connection failed:', error);
                alert('Failed to connect Phantom wallet. Please try again.');
            }
        }


        function onWalletConnected() {
            // Save wallet info to localStorage for persistent login
            localStorage.setItem('walletType', walletType);
            localStorage.setItem('walletAddress', walletAddress);
            localStorage.setItem('walletBalance', walletBalance);
            localStorage.setItem('lastLogin', Date.now().toString());

            // Hide wallet screen
            document.getElementById('walletScreen').classList.add('hidden');
            setTimeout(() => {
                document.getElementById('walletScreen').style.display = 'none';
            }, 300);

            // Update HUD
            document.getElementById('hud').style.display = 'block';
            document.getElementById('hudWallet').textContent = `Wallet: ${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`;
            document.getElementById('hudBalance').textContent = `Balance: ${walletBalance} ${walletType === 'phantom' ? 'SOL' : 'ETH'}`;

            // Show switch wallet button
            document.getElementById('disconnectBtn').textContent = 'Switch Wallet';

            // Show chat
            document.getElementById('chatContainer').style.display = 'flex';

            // Generate player ID from wallet
            myPlayerId = walletAddress;
            console.log('Player ID set to wallet:', myPlayerId);

            // Initialize player after wallet connection
            setTimeout(() => {
                initializePlayer();
            }, 1000);
        }

        function disconnectWallet() {
            walletConnected = false;
            walletAddress = null;
            walletType = null;
            walletBalance = 0;

            // Clear localStorage
            localStorage.removeItem('walletType');
            localStorage.removeItem('walletAddress');
            localStorage.removeItem('walletBalance');
            localStorage.removeItem('lastLogin');

            // Clean up player from database
            if (myPlayerId) {
                supabaseClient
                    .from('players')
                    .delete()
                    .eq('id', myPlayerId)
                    .then(() => console.log('Player cleaned up'))
                    .catch(err => console.error('Cleanup error:', err));
            }

            // Clear intervals
            if (updateInterval) clearInterval(updateInterval);
            if (heartbeatInterval) clearInterval(heartbeatInterval);
            if (chatUpdateInterval) clearInterval(chatUpdateInterval);

            // Reload page to show wallet selection
            window.location.reload();
        }

        // Auto-reconnect wallet on page load
        window.addEventListener('DOMContentLoaded', async () => {
            const savedWalletType = localStorage.getItem('walletType');
            const savedWalletAddress = localStorage.getItem('walletAddress');
            const lastLogin = localStorage.getItem('lastLogin');

            // Auto-reconnect if logged in within last 24 hours
            if (savedWalletType && savedWalletAddress && lastLogin) {
                const hoursSinceLogin = (Date.now() - parseInt(lastLogin)) / (1000 * 60 * 60);

                if (hoursSinceLogin < 24) {
                    console.log('Auto-reconnecting wallet:', savedWalletAddress);

                    try {
                        if (savedWalletType === 'phantom') {
                            const { solana } = window;
                            if (solana?.isPhantom) {
                                const response = await solana.connect({ onlyIfTrusted: true });
                                if (response?.publicKey) {
                                    walletAddress = response.publicKey.toString();
                                    walletType = 'phantom';
                                    walletConnected = true;

                                    // Fetch balance
                                    try {
                                        const connection = new solanaWeb3.Connection(CONFIG.SOLANA_RPC_PRIMARY, 'confirmed');
                                        const balance = await connection.getBalance(response.publicKey);
                                        walletBalance = (balance / solanaWeb3.LAMPORTS_PER_SOL).toFixed(4);
                                    } catch (err) {
                                        walletBalance = 0;
                                    }

                                    onWalletConnected();
                                }
                            }
                        }
                    } catch (error) {
                        console.warn('Auto-reconnect failed:', error);
                        // Clear failed login data
                        localStorage.removeItem('walletType');
                        localStorage.removeItem('walletAddress');
                    }
                }
            }
        });

        // Set up wallet button listeners
        document.getElementById('connectPhantom').addEventListener('click', connectPhantom);
        document.getElementById('disconnectBtn').addEventListener('click', disconnectWallet);

        // Initialize player in Supabase
        async function initializePlayer() {
            try {
                // Insert player into database (minimal for discovery)
                const username = walletAddress ? `${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}` : 'Player';
                const { data, error } = await supabaseRetry(() => supabaseClient
                    .from('players')
                    .insert([{
                        id: myPlayerId,
                        username: username,
                        wallet_address: walletAddress,
                        wallet_type: walletType,
                        color: myColor,
                        last_seen: new Date().toISOString()
                    }])
                    .select());

                if (error) {
                    console.error('Error initializing player:', error);
                    return;
                }

                console.log('Player initialized in Supabase:', data);

                // Show multiplayer UI
                document.getElementById('colorPickerIcon').classList.add('visible');
                document.getElementById('playerCount').classList.add('visible');

                // Start P2P signaling
                subscribeToSignals();

                // Start position updates (P2P hybrid)
                startPositionUpdates();

                // Start heartbeat
                startHeartbeat();

                // Start player cleanup (reduced reliance on Supabase)
                startPlayerCleanup();

                // Subscribe to player changes for discovery
                subscribeToPlayers();

                // Load existing players and initiate P2P for all
                loadExistingPlayers();

                // No Supabase messages subscription or loading - all via P2P

                // Periodically manage P2P connections
                setInterval(manageP2PConnections, 5000);

            } catch (error) {
                console.error('Error in initializePlayer:', error);
            }
        }

// Full mesh P2P: Connect to all players
function manageP2PConnections() {
  otherPlayers.forEach((player, peerId) => {
    if (!peers.has(peerId)) {
      initiateP2P(peerId);
    }
  });
}

// Full P2P position updates
function startPositionUpdates() {
  updateInterval = setInterval(() => {
    sendP2PPosition();
  }, CONFIG.POSITION_UPDATE_INTERVAL);
}

// Full P2P chat
async function sendMessage(text) {
  if (!text || !text.trim()) return;
  if (!walletConnected) return;

  sendP2PChat(text);
  console.log('Message sent via P2P:', text);
  document.getElementById('chatInput').value = '';
  toggleChatInput(false);
}

        // Subscribe to player changes for discovery only (no positions)
function subscribeToPlayers() {
  supabaseClient
    .channel('players-channel')
    .on('postgres_changes', {
      event: 'INSERT',
      schema: 'public',
      table: 'players'
    }, (payload) => {
      if (payload.new.id !== myPlayerId) {
        createOtherPlayer(payload.new.id, payload.new.color, { x: 0, y: 0, z: 0 }, 0); // Initial position dummy
        initiateP2P(payload.new.id); // Connect P2P
        updatePlayerCount();
      }
    })
    .on('postgres_changes', {
      event: 'UPDATE',
      schema: 'public',
      table: 'players'
    }, (payload) => {
      if (payload.new.id !== myPlayerId && payload.new.color !== payload.old?.color) {
        updateOtherPlayerColor(payload.new.id, payload.new.color);
      }
    })
    .on('postgres_changes', {
      event: 'DELETE',
      schema: 'public',
      table: 'players'
    }, (payload) => {
      if (payload.old.id !== myPlayerId) {
        removeOtherPlayer(payload.old.id);
        const pc = peers.get(payload.old.id);
        if (pc) pc.close();
        peers.delete(payload.old.id);
        dataChannels.delete(payload.old.id);
        updatePlayerCount();
      }
    })
    .subscribe();
}

// Add disconnect detection for P2P
peers.forEach((pc, peerId) => {
  pc.onconnectionstatechange = () => {
    if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
      removeOtherPlayer(peerId);
      peers.delete(peerId);
      dataChannels.delete(peerId);
    }
  };
});


        // Load existing players for P2P connection
async function loadExistingPlayers() {
  try {
    const { data: players, error } = await supabaseRetry(() => supabaseClient
      .from('players')
      .select('id, color')
      .neq('id', myPlayerId));

    if (error) {
      console.error('Error loading players:', error);
      return;
    }

    console.log('Loaded existing players:', players);

    players.forEach(player => {
      createOtherPlayer(player.id, player.color, { x: 0, y: 0, z: 0 }, 0);
      initiateP2P(player.id);
    });

    updatePlayerCount();
  } catch (error) {
    console.error('Error in loadExistingPlayers:', error);
  }
}

        // Start heartbeat for presence
function startHeartbeat() {
  heartbeatInterval = setInterval(async () => {
    try {
      await supabaseRetry(() => supabaseClient
        .from('players')
        .update({ last_seen: new Date().toISOString() })
        .eq('id', myPlayerId));
    } catch (error) {
      console.error('Error sending heartbeat:', error);
    }
  }, CONFIG.HEARTBEAT_INTERVAL);
}

// Cleanup using P2P and timeout
let cleanupInterval = null;
function startPlayerCleanup() {
  cleanupInterval = setInterval(() => {
    const now = Date.now();
    otherPlayers.forEach((player, peerId) => {
      if (now - player.lastUpdate > 15000) {
        removeOtherPlayer(peerId);
        const pc = peers.get(peerId);
        if (pc) pc.close();
        peers.delete(peerId);
        dataChannels.delete(peerId);
        updatePlayerCount();
      }
    });
  }, 5000);

  // P2P disconnect handling
  peers.forEach((pc, peerId) => {
    pc.onconnectionstatechange = () => {
      if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed') {
        removeOtherPlayer(peerId);
        peers.delete(peerId);
        dataChannels.delete(peerId);
        updatePlayerCount();
      }
    };
  });
}

        // Clean up on page unload
        window.addEventListener('beforeunload', async () => {
            if (myPlayerId) {
                try {
                    await supabaseClient
                        .from('players')
                        .delete()
                        .eq('id', myPlayerId);
                } catch (error) {
                    console.error('Error cleaning up player:', error);
                }
            }

            if (updateInterval) clearInterval(updateInterval);
            if (heartbeatInterval) clearInterval(heartbeatInterval);
            if (cleanupInterval) clearInterval(cleanupInterval);
        });

        // Player initialization now happens after wallet connection in onWalletConnected()

        function createOtherPlayer(peerId, color, position, rotation) {
            if (otherPlayers.has(peerId)) return;

            console.log('Creating player:', peerId, 'with color:', color);

            const otherPlayer = new THREE.Group();
            otherPlayer.position.set(position.x, position.y, position.z);
            otherPlayer.rotation.y = rotation;

            // Parse color properly
            let playerColor = color;
            if (typeof color === 'string') {
                if (!color.startsWith('#')) {
                    playerColor = '#' + color.replace('0x', '');
                }
            }

            let playerMesh = null;
            let playerMixer = null;
            let animations = { idle: null, walk: null, run: null };
            let currentAction = null;

            // If main player model is loaded, clone it
            if (playerModel) {
                try {
                    // Clone the player model
                    const clonedModel = playerModel.clone();
                    clonedModel.scale.copy(playerModel.scale);

                    // Apply player color to the cloned model
                    clonedModel.traverse((child) => {
                        if (child.isMesh && child.material) {
                            // Clone material to avoid affecting other players
                            child.material = child.material.clone();

                            // Apply player's chosen color to accent parts
                            const currentColor = child.material.color;
                            if (currentColor.r > 0.5 && currentColor.g < 0.5 ||
                                currentColor.r < 0.3 && currentColor.g > 0.7 && currentColor.b > 0.7) {
                                child.material.color = new THREE.Color(playerColor);
                                child.material.emissive = new THREE.Color(playerColor);
                                child.material.emissiveIntensity = 0.3;
                            }
                        }
                    });

                    otherPlayer.add(clonedModel);
                    playerMesh = clonedModel;

                    // Set up animation mixer for this player
                    if (playerMixer && playerMixer.getRoot) {
                        const root = playerMixer.getRoot();
                        if (root.animations) {
                            playerMixer = new THREE.AnimationMixer(clonedModel);

                            root.animations.forEach((clip) => {
                                const name = clip.name.toLowerCase();
                                const action = playerMixer.clipAction(clip);
                                action.setLoop(THREE.LoopRepeat);

                                if (name.includes('idle')) animations.idle = action;
                                else if (name.includes('walk')) animations.walk = action;
                                else if (name.includes('run')) animations.run = action;
                            });

                            // Start with idle
                            if (animations.idle) {
                                animations.idle.play();
                                currentAction = animations.idle;
                            }
                        }
                    }
                } catch (err) {
                    console.warn('Failed to clone player model:', err);
                    playerMesh = null;
                }
            }

            // Fallback to simple capsule if model not available
            if (!playerMesh) {
                const fallbackGeo = new THREE.CapsuleGeometry(0.4, 1.2, 8, 16);
                const fallbackMat = new THREE.MeshStandardMaterial({
                    color: playerColor,
                    emissive: playerColor,
                    emissiveIntensity: 0.4,
                    metalness: 0.6,
                    roughness: 0.4
                });
                playerMesh = new THREE.Mesh(fallbackGeo, fallbackMat);
                playerMesh.position.y = 1;
                otherPlayer.add(playerMesh);
            }

            // Add name tag
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 512, 128);
            ctx.strokeStyle = playerColor;
            ctx.lineWidth = 4;
            ctx.strokeRect(2, 2, 508, 124);
            ctx.fillStyle = playerColor;
            ctx.font = 'bold 32px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(peerId.slice(0, 6) + '...' + peerId.slice(-4), 256, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const label = new THREE.Mesh(
                new THREE.PlaneGeometry(3, 0.75),
                new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide })
            );
            label.position.y = 2.5;
            otherPlayer.add(label);

            scene.add(otherPlayer);
            otherPlayers.set(peerId, {
                group: otherPlayer,
                mesh: playerMesh,
                label: label,
                mixer: playerMixer,
                animations: animations,
                currentAction: currentAction,
                lastPosition: new THREE.Vector3(position.x, position.y, position.z),
                velocity: 0
            });

            updatePlayerCount();
            console.log('Player created with animations:', !!playerMixer);
        }

        function updateOtherPlayer(peerId, position, rotation) {
            const player = otherPlayers.get(peerId);
            if (!player) return;

            const targetPos = new THREE.Vector3(position.x, position.y, position.z);
            const currentPos = player.group.position;

            // Calculate velocity for animation
            if (player.lastPosition) {
                const distance = currentPos.distanceTo(targetPos);
                player.velocity = distance;

                // Determine animation based on velocity
                if (player.animations && player.animations.idle) {
                    let targetAction = null;

                    if (distance < 0.01) {
                        // Not moving - idle
                        targetAction = player.animations.idle;
                    } else if (distance < 0.5) {
                        // Slow movement - walk
                        targetAction = player.animations.walk || player.animations.idle;
                    } else {
                        // Fast movement - run
                        targetAction = player.animations.run || player.animations.walk || player.animations.idle;
                    }

                    // Smoothly transition animations
                    if (targetAction && targetAction !== player.currentAction) {
                        if (player.currentAction) {
                            targetAction.reset();
                            targetAction.crossFadeFrom(player.currentAction, 0.3, true);
                        }
                        targetAction.play();
                        player.currentAction = targetAction;
                    }
                }
            }

            // Smooth interpolation (better smoothing)
            player.group.position.lerp(targetPos, 0.15);

            // Smooth rotation
            const rotDiff = rotation - player.group.rotation.y;
            player.group.rotation.y += rotDiff * 0.15;

            player.lastPosition.copy(targetPos);
        }

        function updateOtherPlayerColor(peerId, color) {
            const player = otherPlayers.get(peerId);
            if (player && player.bodyGroup) {
                // Update all body parts with new color
                player.bodyGroup.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.color.setStyle(color);
                        if (child.material.emissive) {
                            child.material.emissive.setStyle(color);
                        }
                    }
                });
                console.log('Updated player color to:', color);
            }
        }

        function removeOtherPlayer(peerId) {
            const player = otherPlayers.get(peerId);
            if (player) {
                scene.remove(player.group);
                otherPlayers.delete(peerId);
            }
            updatePlayerCount();
        }

        // Chat handled via P2P, no Supabase


        // Set up chat UI listeners
        document.getElementById('sendBtn').addEventListener('click', () => {
            const text = document.getElementById('chatInput').value;
            sendMessage(text);
        });

        document.getElementById('chatInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const text = document.getElementById('chatInput').value;
                sendMessage(text);
            }
        });

        async function updatePlayerCount() {
            try {
                const { data, error } = await supabaseClient
                    .from('players')
                    .select('id', { count: 'exact' });

                if (error) {
                    console.error('Error counting players:', error);
                    return;
                }

                const count = data.length;
                document.getElementById('playerCount').textContent = `Players: ${count}`;
            } catch (error) {
                console.error('Error in updatePlayerCount:', error);
            }
        }

        // Position updates now handled by startPositionUpdates() interval

        // Color picker functionality
        colorInput.addEventListener('change', async (e) => {
            const color = e.target.value;
            myColor = color;

            // Update player body color if it exists
            if (playerBody) {
                playerBody.traverse((child) => {
                    if (child.isMesh) {
                        child.material.color.setStyle(color);
                        child.material.emissive.setStyle(color);
                    }
                });
            }

            // Update color in Supabase
            try {
                await supabaseClient
                    .from('players')
                    .update({ color: color })
                    .eq('id', myPlayerId);
                console.log('Color updated to:', color);
            } catch (error) {
                console.error('Error updating color:', error);
            }

            // Close popup after selecting
            colorPickerOpen = false;
            colorPickerPopup.classList.remove('visible');
        });

        // Position broadcasting handled by Supabase real-time updates

        // Animation loop with advanced features
        function animate(currentTime) {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Update animations with proper delta time
            if (playerMixer) {
                // Ensure delta is reasonable to prevent skipping
                const safeDelta = Math.min(delta, 0.1);
                playerMixer.update(safeDelta);
            }

            // Update other players' animations
            otherPlayers.forEach((player) => {
                if (player.mixer) {
                    const safeDelta = Math.min(delta, 0.1);
                    player.mixer.update(safeDelta);
                }
                // Make name tags face the camera
                if (player.label) {
                    player.label.lookAt(camera.position);
                }
            });

            // FPS counter
            frames++;
            if (currentTime - lastTime >= 1000) {
                fps = frames;
                frames = 0;
                lastTime = currentTime;
            }

            // Calculate movement with sprint
            playerVelocity.set(0, 0, 0);

            // Apply sprint multiplier when shift is held
            const currentSpeed = keys.shift ? moveSpeed * sprintMultiplier : moveSpeed;

            // Keyboard input - always use run animation when moving
            if (keys.w) playerVelocity.z -= currentSpeed;
            if (keys.s) playerVelocity.z += currentSpeed;
            if (keys.a) playerVelocity.x -= currentSpeed;
            if (keys.d) playerVelocity.x += currentSpeed;

            // Mobile joystick input
            if (joystickActive) {
                playerVelocity.x += joystickVector.x * currentSpeed * 1.5;
                playerVelocity.z += joystickVector.y * currentSpeed * 1.5;
            }

            // Apply movement
            const isMoving = playerVelocity.length() > 0;

            if (isMoving) {
                const newX = playerGroup.position.x + playerVelocity.x;
                const newZ = playerGroup.position.z + playerVelocity.z;

                if (!checkCollision(newX, newZ)) {
                    playerGroup.position.x = newX;
                    playerGroup.position.z = newZ;

                    // Smooth rotation towards movement direction
                    const targetAngle = Math.atan2(playerVelocity.x, playerVelocity.z);
                    let angleDiff = targetAngle - playerGroup.rotation.y;

                    // Normalize angle difference
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    playerGroup.rotation.y += angleDiff * 0.15;

                    // Always use run animation for movement
                    const targetAction = runAction || walkAction;

                    if (targetAction) {
                        const needsSwitch = !targetAction.isRunning() || targetAction.weight === 0;

                        if (needsSwitch) {
                            // Stop all other animations
                            if (idleAction) {
                                idleAction.stop();
                                idleAction.weight = 0;
                            }
                            if (walkAction && targetAction === runAction) {
                                walkAction.stop();
                                walkAction.weight = 0;
                            }

                            // Play run animation
                            targetAction.reset();
                            targetAction.setLoop(THREE.LoopRepeat, Infinity);
                            targetAction.clampWhenFinished = false;
                            targetAction.timeScale = 1.0;
                            targetAction.setEffectiveWeight(1);
                            targetAction.enabled = true;
                            targetAction.paused = false;
                            targetAction.play();
                        }
                    }
                }

                // Keep player within circular platform bounds
                const distanceFromCenter = Math.sqrt(
                    playerGroup.position.x * playerGroup.position.x +
                    playerGroup.position.z * playerGroup.position.z
                );
                const maxRadius = 33.75;

                if (distanceFromCenter > maxRadius) {
                    const angle = Math.atan2(playerGroup.position.z, playerGroup.position.x);
                    playerGroup.position.x = Math.cos(angle) * maxRadius;
                    playerGroup.position.z = Math.sin(angle) * maxRadius;
                }
            }

            // Apply jump physics
            if (isJumping) {
                verticalVelocity -= gravity;
                playerGroup.position.y += verticalVelocity;

                // Check if landed
                if (playerGroup.position.y <= groundLevel) {
                    playerGroup.position.y = groundLevel;
                    verticalVelocity = 0;
                    isJumping = false;
                }
            }

            if (!isMoving) {
                // Switch to idle animation - fixed playback
                if (idleAction) {
                    const needsSwitch = !idleAction.isRunning() || idleAction.weight === 0;

                    if (needsSwitch) {
                        // Stop movement animations
                        if (walkAction) {
                            walkAction.stop();
                            walkAction.weight = 0;
                        }
                        if (runAction) {
                            runAction.stop();
                            runAction.weight = 0;
                        }

                        // Play idle animation
                        idleAction.reset();
                        idleAction.setLoop(THREE.LoopRepeat, Infinity);
                        idleAction.clampWhenFinished = false;
                        idleAction.timeScale = 1.0;
                        idleAction.setEffectiveWeight(1);
                        idleAction.enabled = true;
                        idleAction.paused = false;
                        idleAction.play();

                        console.log('Playing idle animation');
                    }
                }
            }

            // Animate atmospheric particles
            const positions = particleGeometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] += particleVelocities[i].x;
                positions[i * 3 + 1] += particleVelocities[i].y;
                positions[i * 3 + 2] += particleVelocities[i].z;

                // Wrap around boundaries
                if (Math.abs(positions[i * 3]) > 40) particleVelocities[i].x *= -1;
                if (positions[i * 3 + 1] > 50 || positions[i * 3 + 1] < 0) particleVelocities[i].y *= -1;
                if (Math.abs(positions[i * 3 + 2]) > 40) particleVelocities[i].z *= -1;
            }
            particleGeometry.attributes.position.needsUpdate = true;

            // Animate corner neon lights
            neonLight1.intensity = 3 + Math.sin(currentTime * 0.003) * 1.5;
            neonLight2.intensity = 3 + Math.sin(currentTime * 0.002 + 1) * 1.5;
            neonLight3.intensity = 3 + Math.sin(currentTime * 0.004 + 2) * 1.5;
            neonLight4.intensity = 3 + Math.sin(currentTime * 0.0025 + 3) * 1.5;

            // Animate first YouTube thumbnail - hover and spin (loot item style)
            videoThumbnailGroup.position.y = 0.5 + Math.sin(currentTime * 0.002) * 0.4;
            videoThumbnailGroup.rotation.y = currentTime * 0.0008;
            borderMesh.material.opacity = 0.7 + Math.sin(currentTime * 0.003) * 0.2;
            outerGlowMesh.material.opacity = 0.2 + Math.sin(currentTime * 0.004) * 0.15;
            thumbnailLight.intensity = 1.5 + Math.sin(currentTime * 0.004) * 0.8;

            // Animate second YouTube thumbnail
            videoThumbnailGroup2.position.y = 0.5 + Math.sin(currentTime * 0.002 + 1) * 0.4;
            videoThumbnailGroup2.rotation.y = currentTime * 0.0008;
            borderMesh2.material.opacity = 0.7 + Math.sin(currentTime * 0.003 + 1) * 0.2;
            outerGlowMesh2.material.opacity = 0.2 + Math.sin(currentTime * 0.004 + 1) * 0.15;
            thumbnailLight2.intensity = 1.5 + Math.sin(currentTime * 0.004 + 1) * 0.8;

            // Animate third loot item (Resume)
            videoThumbnailGroup3.position.y = 0.5 + Math.sin(currentTime * 0.002 + 2) * 0.4;
            videoThumbnailGroup3.rotation.y = currentTime * 0.0008;
            borderMesh3.material.opacity = 0.7 + Math.sin(currentTime * 0.003 + 2) * 0.2;
            outerGlowMesh3.material.opacity = 0.2 + Math.sin(currentTime * 0.004 + 2) * 0.15;
            thumbnailLight3.intensity = 1.5 + Math.sin(currentTime * 0.004 + 2) * 0.8;

            // Animate AGV loot item
            agvGroup.position.y = 0.5 + Math.sin(currentTime * 0.002 + 2.5) * 0.4;
            agvGroup.rotation.y = currentTime * 0.0008;
            agvBorderMesh.material.opacity = 0.7 + Math.sin(currentTime * 0.003 + 2.5) * 0.2;
            agvOuterGlow.material.opacity = 0.2 + Math.sin(currentTime * 0.004 + 2.5) * 0.15;
            agvLight.intensity = 1.5 + Math.sin(currentTime * 0.004 + 2.5) * 0.8;

            // Animate fourth loot item (GitHub)
            videoThumbnailGroup4.position.y = 0.5 + Math.sin(currentTime * 0.002 + 3) * 0.4;
            videoThumbnailGroup4.rotation.y = currentTime * 0.0008;
            borderMesh4.material.opacity = 0.7 + Math.sin(currentTime * 0.003 + 3) * 0.2;
            outerGlowMesh4.material.opacity = 0.2 + Math.sin(currentTime * 0.004 + 3) * 0.15;
            thumbnailLight4.intensity = 1.5 + Math.sin(currentTime * 0.004 + 3) * 0.8;

            // Animate BOB Robot Project (blue)
            bobProjectGroup.position.y = 0.5 + Math.sin(currentTime * 0.002 + 4) * 0.4;
            bobProjectGroup.rotation.y = currentTime * 0.0008;
            bobProjectBorder.material.opacity = 0.7 + Math.sin(currentTime * 0.003 + 4) * 0.2;
            bobProjectGlow.material.opacity = 0.2 + Math.sin(currentTime * 0.004 + 4) * 0.15;
            bobProjectLight.intensity = 1.5 + Math.sin(currentTime * 0.004 + 4) * 0.8;

            // Animate Cover Letter (pink)
            coverLetterGroup.position.y = 0.5 + Math.sin(currentTime * 0.002 + 5) * 0.4;
            coverLetterGroup.rotation.y = currentTime * 0.0008;
            coverBorderMesh.material.opacity = 0.7 + Math.sin(currentTime * 0.003 + 5) * 0.2;
            coverOuterGlow.material.opacity = 0.2 + Math.sin(currentTime * 0.004 + 5) * 0.15;
            coverLetterLight.intensity = 1.5 + Math.sin(currentTime * 0.004 + 5) * 0.8;

            // Show/hide popup based on distance to first thumbnail
            const distToThumbnail = Math.sqrt(
                Math.pow(playerGroup.position.x - thumbnailPosition.x, 2) +
                Math.pow(playerGroup.position.z - thumbnailPosition.z, 2)
            );
            if (distToThumbnail < thumbnailPosition.radius) {
                lootPopup.classList.add('visible');
            } else {
                lootPopup.classList.remove('visible');
            }

            // Show/hide popup based on distance to second thumbnail
            const distToThumbnail2 = Math.sqrt(
                Math.pow(playerGroup.position.x - thumbnailPosition2.x, 2) +
                Math.pow(playerGroup.position.z - thumbnailPosition2.z, 2)
            );
            if (distToThumbnail2 < thumbnailPosition2.radius) {
                lootPopup2.classList.add('visible');
            } else {
                lootPopup2.classList.remove('visible');
            }

            // Show/hide popup based on distance to third thumbnail (Resume)
            const distToThumbnail3 = Math.sqrt(
                Math.pow(playerGroup.position.x - thumbnailPosition3.x, 2) +
                Math.pow(playerGroup.position.z - thumbnailPosition3.z, 2)
            );
            if (distToThumbnail3 < thumbnailPosition3.radius) {
                lootPopup3.classList.add('visible');
            } else {
                lootPopup3.classList.remove('visible');
            }

            // Show/hide popup based on distance to AGV loot
            const distToAgv = Math.sqrt(
                Math.pow(playerGroup.position.x - agvPosition.x, 2) +
                Math.pow(playerGroup.position.z - agvPosition.z, 2)
            );
            if (distToAgv < agvPosition.radius) {
                agvPopup.classList.add('visible');
            } else {
                agvPopup.classList.remove('visible');
            }

            // Show/hide popup based on distance to fourth thumbnail (GitHub)
            const distToThumbnail4 = Math.sqrt(
                Math.pow(playerGroup.position.x - thumbnailPosition4.x, 2) +
                Math.pow(playerGroup.position.z - thumbnailPosition4.z, 2)
            );
            if (distToThumbnail4 < thumbnailPosition4.radius) {
                lootPopup4.classList.add('visible');
            } else {
                lootPopup4.classList.remove('visible');
            }

            // Show/hide BOB Robot Project popup
            const distToBobProject = Math.sqrt(
                Math.pow(playerGroup.position.x - bobProjectPosition.x, 2) +
                Math.pow(playerGroup.position.z - bobProjectPosition.z, 2)
            );
            if (distToBobProject < bobProjectPosition.radius) {
                lootPopupBobProject.classList.add('visible');
            } else {
                lootPopupBobProject.classList.remove('visible');
            }

            // Show/hide Cover Letter popup
            const distToCoverLetter = Math.sqrt(
                Math.pow(playerGroup.position.x - coverLetterPosition.x, 2) +
                Math.pow(playerGroup.position.z - coverLetterPosition.z, 2)
            );
            if (distToCoverLetter < coverLetterPosition.radius) {
                coverLetterPopup.classList.add('visible');
            } else {
                coverLetterPopup.classList.remove('visible');
            }

            // Simple elevated camera following player from fixed angle
            const cameraOffset = new THREE.Vector3(0, 10, 15);
            const cameraPosition = playerGroup.position.clone().add(cameraOffset);

            // Smooth camera movement
            camera.position.lerp(cameraPosition, 0.05);

            // Look at player position
            const lookAtTarget = playerGroup.position.clone().add(new THREE.Vector3(0, 2, 0));
            camera.lookAt(lookAtTarget);

            // Render with post-processing
            composer.render();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);

            // Update FXAA resolution
            const pixelRatio = renderer.getPixelRatio();
            fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * pixelRatio);
            fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * pixelRatio);
        });

        // Start animation immediately
        animate(performance.now());
    </script>
</body>

</html>